/**
* Program:   3-D ping pong (bat controlled through acceleration)
* Author :   Yingfu Zeng, Adam Duracz, Walid Taha
* Date   :   2012/02/20
* License:   BSD, GPL(V2), or other by agreement with Walid Taha
**/




class Virtue(n) 
// Based on WiffWaff's speed-control player.Aim for far edge or net. Make opponent move along X. High shot when you go for net.
     private
      mode      := "Wait";
	  name      := "Virtue";
      bounced   := false;       // Tell whether the ball bounced or not
      serve := false;           // The Game class will set serve flag to true
      hit   := false;           // when it's your turn
      count := 0;
      ballv := [0,0,0];
      ballp := [0,0,0];
      batp  := [1.6,0,0.2];
      v     := [0,0,0];         // Bat's speed
      a     := [0,0,0];         // Bat's acceleration (computed by controller)
      estimatedBatV  := [0,0,0]; // Predicted result of acceleration
      estimatedBatV' := [0,0,0]; // Equated to computed acceleration signal
      desiredBatP  := [1.6*(-1)^n,0,0.2];     // Desired bat position (from derive)
      desiredBatP' := [0,0,0];     // Desired bat speed (from naive)
      batAngle   := [0,0,0.1];  // Normal vector of the bat's plane
      batAngle'  := [0,0,0];
      // Player(1) starts at [-1.6,0,0.2], Player(2) starts at [1.6,0,0.2]
      startPoint := [1.6*(-1)^n,0,0.2];
      v2         := [0,0,0];    // The output speed of the ball, which we desired
      v21        := [0,0,0];
      z   := 0;
      n1   := 0;
      t   := 0;
      t'  := 1;
      number := n;
      delta := 0;
      delta2 := 0;
      mult := 0.7;
      mult2 := 0.7;
     end
     number = n;
     startPoint = [1.6*(-1)^number,0,0.2];
     if mode ~= "Wait" && mode ~= "Prepare" && mode ~= "Hit"
       mode := "Panic!";
     end;
     t'  = 1;
     switch mode
      case "Wait"               // While waiting, moving the bat to starting point
       count      := 0;
           a = -100000*v;
       //v = [0,0,0];
       if n == 1
         v         = [0,0,0];
       else
         v         = [0,0,0];
       end;
       batAngle' = [0,0,0]-batAngle;//different angle from opponent
       hit    := false;
       if serve == true
        mode    := "Prepare";
        bounced := false;
       else
        mode := "Wait";
       end;
      case "Prepare"             // Prepare to hit the ball
       if bounced == true        // After the ball has bounced,
                             // start moving the bat towards the ball
         v = (ballp-batp).*[0,30,0] + (ballp-batp).*[0,0,25] +
                   (ballp-batp).*[25,0,0];
         if norm(batp - ballp)<0.08
          count := count+1;
          mode  := "Hit";
         end;
       end;
       // When the ball has bounced and it is at the highest position
      // if count > 0 && dot(ballv,[0,0,1]) < 0.1 && bounced == true
       // mode := "Hit";     // This player decide to hit.
      // end;
       if dot(ballp,[0,0,1]) < 0 && bounced == false
        bounced := true;
       end;
       if(serve ~= true)
         mode := "Wait";
       end;
     case "Hit"           // Decide how you want hit the ball,
      if n == 2
        v2  := [-(dot(ballp, [1,0,0] ) + 0.75 + 0.5 ), -dot( ballp, [0,1,0]
    ), 5 - dot(ballp,[0,0,1])];
        v21 := (v2 - ballv) / (-2) ;
        n1   :=  norm(v21);
        delta := (1.6-dot(desiredBatP, [1,0, 0]));
        if(dot(ballp, [1,0,0])<1 || dot(ballp, [1,0,0])>1.8 )
            batAngle := (v21 / n1)*(1-(delta/12));
        else
            batAngle := (v21 / n1)*(1+(delta/10));
        end;
        
        z := (n1- dot(batAngle, [1,0,0])*4) / dot(batAngle, [0,0,1]);
        v := ballv - [4, 0,z];
      else
        v2  := [(-dot(ballp, [1,0,0] ) + 0.75 + 0.5 ), -dot( ballp, [0,1,0]
    ), 5 - dot(ballp,[0,0,1])];
        v21 := (v2 - ballv) / (-2) ;
        n1   :=  norm(v21);
        delta2 := (1.6+dot(desiredBatP, [1,0,0]));
        batAngle := (v21 / n1)*(1-(delta2/12));
        
        z := (n1- dot(batAngle, [1,0,0])*4) / dot(batAngle, [0,0,1]);
        mult2 := 0.15;
        v := ballv - [4,0,z];
       end;
      serve  := false;
      hit    := true;
          startPoint := batp;
      mode   := "Wait";
      desiredBatP := startPoint;
      if n == 1
       estimatedBatV := v - [0,0,10];    
      else
       estimatedBatV := v ;
      end;
     case "Panic!"
     end;
    
         // Compute the desired position based on the computed "control" speed
         desiredBatP' = v;

         // Basic controller to actuate acceleration
             a = (13*(desiredBatP'-estimatedBatV)+[0,0,0] + 50*(desiredBatP-batp));

         // Keep track of effect of acceleration to estimate actual bat speed
         estimatedBatV' = a;
    end

	
class Panther(n) // Based on WiffWaff's speed-control player, make his opponents move
 private
  name     := "Panther";
  mode      := "Wait";
  bounced   := false;       // Tell whether the ball bounced or not
  serve := false;           // The Game class will set serve flag to true
  hit   := false;           // when it's your turn
  count := 0;
  ballv := [0,0,0];
  ballp := [0,0,0];
  batp  := [1.6,0,0.2];
  v     := [0,0,0];         // Bat's speed
  a     := [0,0,0];         // Bat's acceleration (computed by controller)
  estimatedBatV  := [0,0,0]; // Predicted result of acceleration
  estimatedBatV' := [0,0,0]; // Equated to computed acceleration signal
  desiredBatP  := [1.6*(-1)^n,0,0.2];     // Desired bat position (from derive)
  desiredBatP' := [0,0,0];     // Desired bat speed (from naive)
  batAngle   := [0,0,0.1];  // Normal vector of the bat's plane
  batAngle'  := [0,0,0];
  // Player(1) starts at [-1.6,0,0.2], Player(2) starts at [1.6,0,0.2]
  startPoint := [1.6*(-1)^n,0,0.2];
  v2         := [0,0,0];    // The output speed of the ball, which we desired
  v21        := [0,0,0];
  z   := 0;
  n1   := 0;
  t   := 0;
  t'  := 1;
  number := n;
//
ballvHorCos := 0; //The value of cos which is the angle between ball velocity and horizontal axis(x)
ballvVerSin := 0; //The value of cos which is the angle between ball velocity and vertical axis(y)
ballpEdgeAngle := 0; //The angle of the angle between ball velocity and edge
//4 vertex of table
balltoEdge := [0,0,0];
//Estimated value
estimatedDistance := 0;
estimatedBallV := [0,0,0];
estimatedBatV := [0,0,0];
estimatedHeight := 0.5;
//Gravity
g := 9.8;
//Coefficient
coeff := 1.1;
 end
 number = n;
 startPoint = [1.6*(-1)^number,0,0.2];
 if mode ~= "Wait" && mode ~= "Prepare" && mode ~= "Hit"
   mode := "Panic!";
 end;
 t'  = 1;
 switch mode
  case "Wait"               // While waiting, moving the bat to starting point
   count      := 0;
   if n == 1
     v         = startPoint-batp;
   else
     v         = startPoint-batp;
   end;
   batAngle' = [0,0,0]-batAngle;
   hit    := false;
   if serve == true
    mode    := "Prepare";
    bounced := false;
   else
    mode := "Wait";
   end;
  case "Prepare"             // Prepare to hit the ball
   if bounced == true        // After the ball has bounced,
                             // start moving the bat towards the ball
     v = (ballp-batp).*[0,30,0] + (ballp-batp).*[0,0,25] +
                   (ballp-batp).*[25,0,0];
     if norm(batp - ballp)<0.08
      count := count+1;
      mode  := "Hit";
     end;
   end;
   // When the ball has bounced and it is at the highest position
  // if count > 0 && dot(ballv,[0,0,1]) < 0.1 && bounced == true
   // mode := "Hit";     // This player decide to hit.
  // end;
   if dot(ballp,[0,0,1]) < 0 && bounced == false
    bounced := true;
   end;
   if(serve ~= true)
     mode := "Wait";
   end;
 case "Hit"           // Decide how you want hit the ball,
  if n == 2
    ballvHorCos := dot(ballv,[(-1)^n,0,0])/norm(ballv)*norm([(-1)^n,0,0]);
    ballvVerSin := (-dot(ballv,[0,0,1])+dot(ballv,[0,1,0]))/norm(ballv)*norm([0,1,0]);
    if(ballvHorCos >= 0.7 && ballvHorCos <= 1)
        if(ballvVerSin > 0)
            balltoEdge := ballp-[(-1)^(n-1)*1.5,(-1)^(n-1)*0.75,0];
            ballpEdgeAngle := acos(dot(balltoEdge,[(-1)^(n-1),0,0])/norm(balltoEdge)*norm([(-1)^(n-1),0,0]));
        else
            balltoEdge := ballp-[(-1)^(n-1)*1.5,(-1)^n*0.75,0];
            ballpEdgeAngle := acos(dot(balltoEdge,[(-1)^(n-1),0,0])/norm(balltoEdge)*norm([(-1)^(n-1),0,0]));
        end;
    else
        balltoEdge := ballp-[(-1)^(n-1)*1.5,0,0];
        ballpEdgeAngle :=  acos(dot(balltoEdge,[(-1)^(n-1),0,0])/norm(balltoEdge)*norm([(-1)^(n-1),0,0]));
    end;

    if(n == 2)
        if(dot(batp,[0,1,0])>=0)
            ballpEdgeAngle := -ballpEdgeAngle;
        end;
    else
        if(dot(batp,[0,1,0])<0)
            ballpEdgeAngle := -ballpEdgeAngle;
        end;
    end;

    estimatedDistance := norm(balltoEdge);
    estimatedBallV := [sqrt((estimatedDistance^2)*g/2*estimatedHeight)*cos(ballpEdgeAngle),sqrt((estimatedDistance^2)*g/2*estimatedHeight)*sin(ballpEdgeAngle),sqrt(2*g*estimatedHeight)];
    v2  := estimatedBallV/coeff;
    v21 := (v2 - ballv) / (-2) ;
    n1   :=  norm(v21);
    batAngle := v21 / n1;
    z := (n1- dot(batAngle, [1,0,0])*4) / dot(batAngle, [0,0,1]);
    v := ballv - [4,0,z];
    
 else
    v2  := [(-dot(ballp, [1,0,0] ) + 0.75 + 0.5 ), -dot( ballp, [0,1,0]), 5 - dot(ballp,[0,0,1])];
    v21 := (v2 - ballv) / (-2) ;
    n1   :=  norm(v21);
    batAngle := v21 / n1;
    z := (n1- dot(batAngle, [1,0,0])*4) / dot(batAngle, [0,0,1]);
    v := ballv - [4,0,z];
end;
  serve  := false;
  hit    := true;
  mode   := "Wait";
  desiredBatP := startPoint;
  if n == 1
   estimatedBatV := v - [0,0,10];
  else
   estimatedBatV := v ;
  end;
 case "Panic!"
 end;
 
    // Compute the desired position based on the computed "control" speed
     desiredBatP' = v;

     // Basic controller to actuate acceleration
     a = 13*(desiredBatP'-estimatedBatV)+ 50*(desiredBatP-batp); 

    // Keep track of effect of acceleration to estimate actual bat speed
     estimatedBatV' = a;
end



class ParadoX(n) 
// Based on WiffWaff's speed-control player,always aim at the opposite edge.
    private
	    name := "ParadoX";
        mode := "Wait";
        bounced := false; // Tell whether the ball bounced or not
        serve := false; // The Game class will set serve flag to true
        hit := false; // when it's your turn
        count := 0;
        ballv := [0,0,0];
        ballp := [0,0,0];
        batp := [1.6,0,0.2];
        v := [0,0,0]; // Bat's speed
        a := [0,0,0]; // Bat's acceleration (computed by controller)
        estimatedBatV := [0,0,0]; // Predicted result of acceleration
        estimatedBatV' := [0,0,0]; // Equated to computed acceleration signal
        desiredBatP := [1.6*(-1)^n,0,0.2]; // Desired bat position (from derive)
        desiredBatP' := [0,0,0]; // Desired bat speed (from naive)
        batAngle := [0,0,0.1]; // Normal vector of the bat's plane
        batAngle' := [0,0,0];
    // Player(1) starts at [-1.6,0,0.2], Player(2) starts at [1.6,0,0.2]
        startPoint := [1.6*(-1)^n,0,0.2];
        v2 := [0,0,0]; // The output speed of the ball, which we desired
        v21 := [0,0,0];
        z := 0;
        n1 := 0;
        t := 0;
        t' := 1;
        D := [1.6*(-1)^n,0,0];
        Dt := 0;
        Dflag := false;
        hitBack := false;
        number := n;
    end
    number = n;
    startPoint = [1.6*(-1)^number,0,0.2];
    
    if mode ~= "Wait" && mode ~= "Prepare" && mode ~= "Hit"
        mode := "Panic!";
    end;
    
    t' = 1;
    
    switch mode
    case "Wait" // While waiting, moving the bat to starting point
        count := 0;
        v = startPoint-batp;
        batAngle' = [0,0,0]-batAngle;
        hit := false;
        if serve == true
            mode := "Prepare";
            bounced := false;
            Dflag := true;
        else
            mode := "Wait";
        end;
    case "Prepare" // Prepare to hit the ball after the ball has bounced, start moving the bat towards the ball
        if bounced == true
            if( Dflag )
                Dflag := false;
                hitBack := true;
            end;
            if( dot(ballv,[0,0,1]) < 0 ) && ( abs(dot(ballp,[1,0,0])) < 1.5 ) && ( dot(ballp,[0,0,1] ) > 0.1 )
                hitBack := false;
            end;
            if( hitBack )
                v = (ballp-batp).*[0,30,0] + (ballp-batp).*[0,0,25];
            else
                v = (ballp-batp).*[0,30,0] + (ballp-batp).*[0,0,25] + (ballp-batp).*[25,0,0];
            end;
            if norm(batp - ballp)<0.15
                count := count+1;
                mode := "Hit";
            end;
        end;
        // When the ball has bounced and it is at the highest position
        // if count > 0 && dot(ballv,[0,0,1]) < 0.1 && bounced == true
        // mode := "Hit"; // This player decide to hit.
        // end;
        if dot(ballp,[0,0,1]) < 0 && bounced == false
            bounced := true;
        end;
        if(serve ~= true)
            mode := "Wait";
        end;
    case "Hit" // Decide how you want hit the ball,
        if n == 2
            v2 := [-(dot(ballp, [1,0,0] ) + 0.75 + 0.5 ), -dot( ballp, [0,1,0] ), 5 - dot(ballp,[0,0,1])];
            v21 := (v2 - ballv) / (-2) ;
            n1 := norm(v21);
            batAngle := v21 / n1;
            z := (n1- dot(batAngle, [1,0,0])*4) / dot(batAngle, [0,0,1]);
            v := ballv - [4,0,z];
        else
            v2 := [(-dot(ballp, [1,0,0] ) + 0.75 + 0.5 ), -dot( ballp, [0,1,0] ), 5 - dot(ballp,[0,0,1])];
            v21 := (v2 - ballv) / (-2) ;
            n1 := norm(v21);
            batAngle := v21 / n1;
            z := (n1- dot(batAngle, [1,0,0])*4) / dot(batAngle, [0,0,1]);
            v := ballv - [4,0,z];
        end;
        if( dot(ballp,[0,1,0]) > 0 )
            batAngle := batAngle + [0,0.1,0] + dot(ballp,[0,1,0])/15;
        else
            batAngle := batAngle + [0,-0.1,0] + dot(ballp,[0,1,0])/15;
        end;
        if( n == 1 )
            batAngle := batAngle + [ -dot(batp,[1,0,0])*0.09/1.6, 0, 0.03 ];
            else
            batAngle := batAngle + [ dot(batp,[1,0,0])*0.05/1.6, 0, 0 ];
        end;
        serve := false;
        hit := true;
        mode := "Wait";
        desiredBatP := startPoint;
        if n == 1
            estimatedBatV := v - [-5,0,12];
        else
            estimatedBatV := v ;
        end;
    case "Panic!"
    end;
    // Compute the desired position based on the computed "control" speed
    desiredBatP' = v;
    // Basic controller to actuate acceleration
    a = 13*(desiredBatP'-estimatedBatV)+ 50*(desiredBatP-batp);
    // Keep track of effect of acceleration to estimate actual bat speed
    estimatedBatV' = a;
end


class XPTO(n) 
// Based on WiffWaff's speed-control player, aim the end of table, edges. ¡°Aggressive player¡±.
 private
  name := "XPTO";
  mode      := "Wait";
  bounced   := false;       // Tell whether the ball bounced or not
  serve := false;           // The Game class will set serve flag to true
  hit   := false;           // when it's your turn
  count := 0;
  ballv := [0,0,0];
  ballp := [0,0,0];
  batp  := [1.6,0,0.2];
  v     := [0,0,0];         // Bat's speed
  a     := [0,0,0];         // Bat's acceleration (computed by controller)
  estimatedBatV  := [0,0,0]; // Predicted result of acceleration
  estimatedBatV' := [0,0,0]; // Equated to computed acceleration signal
  desiredBatP  := [1.6*(-1)^n,0,0.2];     // Desired bat position (from derive)
  desiredBatP' := [0,0,0];     // Desired bat speed (from naive)
  batAngle   := [0,0,0.1];  // Normal vector of the bat's plane
  batAngle'  := [0,0,0];
  // Player(1) starts at [-1.6,0,0.2], Player(2) starts at [1.6,0,0.2]
  startPoint := [1.6*(-1)^n,0,0.2];
  v2         := [0,0,0];    // The output speed of the ball, which we desired
  v21        := [0,0,0];
  z   := 0;
  n1   := 0;
  t   := 0;
  t'  := 1;
  number := n;
 end
 number = n;
 startPoint = [1.6*(-1)^number,0,0.2];
 if mode ~= "Wait" && mode ~= "Prepare" && mode ~= "Hit"
   mode := "Panic!";
 end;
 t'  = 1;
 switch mode
  case "Wait"               // While waiting, moving the bat to starting point
   count      := 0;
   if n == 1
     v         = startPoint-batp;
   else
     v         = startPoint-batp;
   end;
   batAngle' = [0,0,0]-batAngle;
   hit    := false;
   if serve == true
    mode    := "Prepare";
    bounced := false;
   else
    mode := "Wait";
   end;
  case "Prepare"             // Prepare to hit the ball
   if bounced == true        // After the ball has bounced,
                             // start moving the bat towards the ball
     v = (ballp-batp).*[0,30,0] + (ballp-batp).*[0,0,25] +
                   (ballp-batp).*[25,0,0];
     if norm(batp - ballp)<0.08
      count := count+1;
      mode  := "Hit";
     end;
   end;
   // When the ball has bounced and it is at the highest position
  // if count > 0 && dot(ballv,[0,0,1]) < 0.1 && bounced == true
   // mode := "Hit";     // This player decide to hit.
  // end;
   if dot(ballp,[0,0,1]) < 0 && bounced == false
    bounced := true;
   end;
   if(serve ~= true)
     mode := "Wait";
   end;
 case "Hit"           // Decide how you want hit the ball,
  if n == 2
    v2  := [-(dot(ballp, [1,0,0] ) + 0.75 + 1.5 ), -dot( ballp, [0,1,0]
)+0.9, 5 - dot(ballp,[0,0,1])];
        v21 := (v2 - ballv) / (-2) ;
        n1   :=  norm(v21);
        batAngle := v21 / n1;
        z := (n1- dot(batAngle, [1,0,0])*4) / dot(batAngle, [0,0,1]);
        v := ballv - [4,0,z];
        //v        := [-0.5,0.71,1.37];
       //batAngle := [0.87,0.14,-0.47];
  else
    v2  := [(-dot(ballp, [1,0,0] ) + 0.75 + 1.5 ), -dot( ballp, [0,1,0]
)+0.9, 5 - dot(ballp,[0,0,1])];
        v21 := (v2 - ballv) / (-2) ;
        n1   :=  norm(v21);
        batAngle := v21 / n1;
        z := (n1- dot(batAngle, [1,0,0])*4) / dot(batAngle, [0,0,1]);
        v := ballv - [4,0,z];
   end;
  serve  := false;
  hit    := true;
  mode   := "Wait";
  desiredBatP := startPoint;
  if n == 1
   estimatedBatV := v - [0,0,10];
  else
   estimatedBatV := v ;
  end;
 case "Panic!"
 end;
 
    // Compute the desired position based on the computed "control" speed
     desiredBatP' = v;

     // Basic controller to actuate acceleration
     // x'' := -(x'-goal) := goal - x'
     // x'' := x' - x' + x - x
     a = 19*(desiredBatP'-estimatedBatV)+ 75*(desiredBatP-batp);

     // Keep track of effect of acceleration to estimate actual bat speed
     estimatedBatV' = a;
end


   

class WiffWaff(n) // Based on WiffWaff's speed-control player
 private
  name := "WiffWaff";
  mode      := "Wait";
  bounced   := false;       // Tell whether the ball bounced or not
  serve := false;           // The Game class will set serve flag to true
  hit   := false;           // when it's your turn
  count := 0;
  ballv := [0,0,0];
  ballp := [0,0,0];
  batp  := [1.6,0,0.2];
  v     := [0,0,0];         // Bat's speed
  a     := [0,0,0];         // Bat's acceleration (computed by controller)
  aTemp := [0,0,0];
  estimatedBatV  := [0,0,0]; // Predicted result of acceleration
  estimatedBatV' := [0,0,0]; // Equated to computed acceleration signal
  desiredBatP  := [1.6*(-1)^n,0,0.2];     // Desired bat position (from derive)
  desiredBatP' := [0,0,0];     // Desired bat speed (from naive)
  batAngle   := [0,0,0.1];  // Normal vector of the bat's plane
  batAngle'  := [0,0,0];
  // Player(1) starts at [-1.6,0,0.2], Player(2) starts at [1.6,0,0.2]
  startPoint := [1.6*(-1)^n,0,0.2];
  v2         := [0,0,0];    // The output speed of the ball, which we desired
  v21        := [0,0,0];
  z   := 0;
  n1   := 0;
  t   := 0;
  t'  := 1;
  number := n;
  reStart := false;
 end
 
number = n;
 startPoint = [1.6*(-1)^number,0,0.2];
 if mode ~= "Wait" && mode ~= "Prepare" && mode ~= "Hit"
   mode := "Panic!";
 end;
 t'  = 1;
 if batp == [1.6,0,0.2]
   reStart := true;
 end;
 switch mode
  case "Wait"               // While waiting, moving the bat to starting point
   count      := 0;
   if n == 1
     v         = startPoint-batp;
   else
     v         = startPoint-batp;
   end;
   batAngle' = [0,0,0]-batAngle;
   hit    := false;
   if serve == true
    mode    := "Prepare";
    bounced := false;
   else
    mode := "Wait";
   end;
  case "Prepare"             // Prepare to hit the ball
   if bounced == true && dot(batp, [0,0,1]) > 0.1       // After the ball has bounced,
                             // start moving the bat towards the ball
     v = (ballp-batp).*[0,30,0] + (ballp-batp).*[0,0,30] +
                   (ballp-batp).*[30,0,0];
     if norm(batp - ballp)<0.15
      count := count+1;
      mode  := "Hit";
     end;
   end;
   // When the ball has bounced and it is at the highest position
  // if count > 0 && dot(ballv,[0,0,1]) < 0.1 && bounced == true
   // mode := "Hit";     // This player decide to hit.
  // end;
   if dot(ballp,[0,0,1]) < 0 && bounced == false
    bounced := true;
   end;
   if(serve ~= true)
     mode := "Wait";
   end;
 case "Hit"           // Decide how you want hit the ball,
  if n == 2
    v2  := [-(dot(ballp, [1,0,0] ) + 0.65 + 0.5 ), -dot( ballp, [0,1,0]
), 5 - dot(ballp,[0,0,1])];
        v21 := (v2 - ballv) / (-2) ;
        n1   :=  norm(v21);
        batAngle := v21 / n1;
        z := (n1- dot(batAngle, [1,0,0])*4) / dot(batAngle, [0,0,1]);
        v := ballv - [4,0,z];
        //v        := [-0.5,0.71,1.37];
       //batAngle := [0.87,0.14,-0.47];
  else
    v2  := [(-dot(ballp, [1,0,0] ) + 0.65 + 0.5 ), -dot( ballp, [0,1,0]
), 5 - dot(ballp,[0,0,1])];
        v21 := (v2 - ballv) / (-2) ;
        n1   :=  norm(v21);
        batAngle := v21 / n1;
        z := (n1- dot(batAngle, [1,0,0])*4) / dot(batAngle, [0,0,1]);
        v := ballv - [4,0,z];
   end;
  serve  := false;
  hit    := true;
  mode   := "Wait";
  reStart := false;
  desiredBatP := startPoint;
  if n == 1
   estimatedBatV := v - [0,0,10];
  else
   estimatedBatV := v ;
  end;
 case "Panic!"
 end;
      // Compute the desired position based on the computed "control" speed
     desiredBatP' = v;
     // Basic controller to actuate acceleration
     aTemp = 13*(desiredBatP'-estimatedBatV)+ 50*(desiredBatP-batp);
   if n == 2
     if reStart == true
       a  = [0,1,0.4] .* aTemp;
     else
       a  = aTemp;
     end;
  end;
    if n == 1
      a =  13*(desiredBatP'-estimatedBatV)+ 50*(desiredBatP-batp);
    end;
     // Keep track of effect of acceleration to estimate actual bat speed
     estimatedBatV' = a;
end   
   
   

class PingPing(n) 
// Based on WiffWaff's speed-control player, improvement to serve. Setting a target to aim for net on every serve.
 private
  name      := "PingPing";
  mode      := "Wait";
  bounced   := false;       // Tell whether the ball bounced or not
  serve := false;           // The Game class will set serve flag to true
  hit   := false;           // when it's your turn
  count := 0;
  ballv := [0,0,0];
  ballp := [0,0,0];
  batp  := [1.6,0,0.2];
  scount := 0;
  v     := [0,0,0];         // Bat's speed
  a     := [0,0,0];         // Bat's acceleration (computed by controller)
  estimatedBatV  := [0,0,0]; // Predicted result of acceleration
  estimatedBatV' := [0,0,0]; // Equated to computed acceleration signal
  desiredBatP  := [1.6*(-1)^n,0,0.2];     // Desired bat position (from derive)
  desiredBatP' := [0,0,0];     // Desired bat speed (from naive)
  batAngle   := [0,0,0.1];  // Normal vector of the bat's plane
  batAngle'  := [0,0,0];
  // Player(1) starts at [-1.6,0,0.2], Player(2) starts at [1.6,0,0.2]
  startPoint := [1.6*(-1)^n,0,0.2];
  v2         := [0,0,0];    // The output speed of the ball, which we desired
  v21        := [0,0,0];
  z   := 0;
  n1   := 0;
  t   := 0;
  t'  := 1;
  number := n;
 end
 number = n;
 startPoint = [1.6*(-1)^number,0,0.2];
 if mode ~= "Wait" && mode ~= "Prepare" && mode ~= "Hit"
   mode := "Panic!";
 end;
 t'  = 1;
 switch mode
  case "Wait"               // While waiting, moving the bat to starting point
   count      := 0;
   if batp == startPoint
     scount := 0;
   end;
   if n == 1
     v         =  [0,0,0] ;
   else
     v        = [0,0,0];
   end;
   batAngle' = [0,0,0]-batAngle;
   hit    := false;
   if serve == true
    mode    := "Prepare";
    bounced := false;
   else
    mode := "Wait";
   end;
  case "Prepare"             // Prepare to hit the ball
  if(serve == true && scount == 0)

   if bounced == true        // After the ball has bounced,
                             // start moving the bat towards the ball
     v = (ballp-batp).*[0,20,0] + (ballp-batp).*[0,0,25] +
            (ballp+[0.12*(-1)^n,0,0]-batp).*[0,0,0];
     if norm(batp - ballp)<0.15 && abs(dot(ballp,[1,0,0])) >= 
                               abs(dot(startPoint,[1,0,0]))
      count := count+1;
      mode  := "Hit";
     end;
   end;
   // When the ball has bounced and it is at the highest position
   if count > 0 && dot(ballv,[0,0,1]) < 0.1 && bounced == true  
        mode := "Hit";     // This player decide to hit.
   end;
   if dot(ballp,[0,0,1]) < 0 && bounced == false
    bounced := true;
   end;
   if(serve ~= true)
     mode := "Wait";
   end;

  else
    if bounced == true        // After the ball has bounced,
                             // start moving the bat towards the ball
     v = (ballp-batp).*[0,30,0] + (ballp-batp).*[0,0,25] +
                   (ballp-batp).*[25,0,0];
     if norm(batp - ballp)<0.08
      count := count+1;
      mode  := "Hit";
     end;
   end;
   // When the ball has bounced and it is at the highest position
  // if count > 0 && dot(ballv,[0,0,1]) < 0.1 && bounced == true
   // mode := "Hit";     // This player decide to hit.
  // end;
   if dot(ballp,[0,0,1]) < 0 && bounced == false
    bounced := true;
   end;
   if(serve ~= true)
     mode := "Wait";
   end;
  end; 
case "Hit"           // Decide how you want hit the ball,
  if n == 2
    if(serve == true && scount == 0)
    if(dot(ballp,[0,1,0]) > 0)
      v        := [-1,0.2,1.2];
        batAngle := [dot(ballp,[1,0,0])+1.3,dot(ballp,[0,1,0])+0.7,-0.2]/
      norm([dot(ballp,[1,0,0])+1.3,dot(ballp,[0,1,0])+0.7,-0.2]);    
    else
      v        := [-1,0.2,1.2];
        batAngle := [dot(ballp,[1,0,0])+1.3,dot(ballp,[0,1,0])-0.7,-0.2]/
      norm([dot(ballp,[1,0,0])+1.3,dot(ballp,[0,1,0])+0.7,-0.2]);
    end;    
    if(dot(ballp,[0,1,0]) <= 0.2 && dot(ballp,[0,1,0]) >= -0.2)
      v        := [-1,0,1.2];
        batAngle := [0.95,0,-0.2];
    end;      
        scount := 1;
     else
     v2  := [-(dot(ballp, [1,0,0] ) + 0.75 + 0.5 ), -dot( ballp, [0,1,0]
), 5 - dot(ballp,[0,0,1])];
        v21 := (v2 - ballv) / (-2) ;
        n1   :=  norm(v21);
        batAngle := v21 / n1;
        z := (n1- dot(batAngle, [1,0,0])*4) / dot(batAngle, [0,0,1]);
        v := ballv - [4,0,z];
        //v        := [-0.5,0.71,1.37];
       //batAngle := [0.87,0.14,-0.47];  
     end;
  else
    v2  := [(-dot(ballp, [1,0,0] ) + 0.75 + 0.5 ), -dot( ballp, [0,1,0]
), 5 - dot(ballp,[0,0,1])];
        v21 := (v2 - ballv) / (-2) ;
        n1   :=  norm(v21);
        batAngle := v21 / n1;
        z := (n1- dot(batAngle, [1,0,0])*4) / dot(batAngle, [0,0,1]);
        v := ballv - [4,0,z];
   end;
  serve  := false;
  hit    := true;
  mode   := "Wait";
  //desiredBatP := startPoint;
  desiredBatP := batp;
  if n == 1
   estimatedBatV := v - [0,0,10];
  else
   estimatedBatV := v ;
  end;
 case "Panic!"
 end;
 
    // Compute the desired position based on the computed "control" speed
     desiredBatP' = v;

     // Basic controller to actuate acceleration
     if(serve == true && scount == 0)
    a = 13*(desiredBatP'-estimatedBatV) + 1*(desiredBatP-batp);  
     else
    a = 13*(desiredBatP'-estimatedBatV) + 50*(desiredBatP-batp); 
    end;
     

     // Keep track of effect of acceleration to estimate actual bat speed
     estimatedBatV' = a;
end



class Pisces(n) 
// Based on WiffWaff's speed-control player, more back as defense. Don¡¯t move as server.
private
 name := "Pisces";
 mode      := "Wait";
 bounced   := false;       // Tell whether the ball bounced or not
 serve := false;           // The Game class will set serve flag to true
 hit   := false;           // when it's your turn
 count := 0;
 ballv := [0,0,0];
 ballp := [0,0,0];
 batp  := [1.6,0,0.2];
 v     := [0,0,0];         // Bat's speed
 a     := [0,0,0];         // Bat's acceleration (computed by controller)
 estimatedBatV  := [0,0,0]; // Predicted result of acceleration
 estimatedBatV' := [0,0,0]; // Equated to computed acceleration signal
 desiredBatP  := [1.6*(-1)^n,0,0.2];     // Desired bat position (from derive)
 desiredBatP' := [0,0,0];     // Desired bat speed (from naive)
 batAngle   := [0,0,0.1];  // Normal vector of the bat's plane
 batAngle'  := [0,0,0];
 // Player(1) starts at [-1.6,0,0.2], Player(2) starts at [1.6,0,0.2]
 startPoint := [1.6*(-1)^n,0,0.2];
 v2         := [0,0,0];    // The output speed of the ball, which we desired
 v21        := [0,0,0];
 z   := 0;
 n1   := 0;
 t   := 0;
 t'  := 1;
 number := n;
end
number = n;
startPoint = [1.6*(-1)^number,0,0.2];
if mode ~= "Wait" && mode ~= "Prepare" && mode ~= "Hit"
  mode := "Panic!";
end;
t'  = 1;
switch mode
 case "Wait"               // While waiting, moving the bat to starting point
  count      := 0;
  if n == 1
   v         = [-0.75,0,0.5]-batp;
  else
if n == 2
   v         = [0,0,0];
  end;
end;
  batAngle' = [0,0,0]-batAngle;
  hit    := false;
  if serve == true
   mode    := "Prepare";
   bounced := false;
  else
   mode := "Wait";
  end;
 case "Prepare"             // Prepare to hit the ball
  if bounced == true        // After the ball has bounced,
                            // start moving the bat towards the ball
    v = (ballp-batp).*[0,30,0] + (ballp-batp).*[0,0,25] +
                  (ballp-batp).*[25,0,0];
    if norm(batp - ballp)<0.08
     count := count+1;
     mode  := "Hit";
    end;
  end;
  if dot(ballp,[0,0,1]) < 0 && bounced == false
   bounced := true;
  end;
  if(serve ~= true)
    mode := "Wait";
  end;
case "Hit"           // Decide how you want hit the ball,
 if n == 2
   v2  := [-(dot(ballp, [1,0,0] ) + 0.75 + 0.5 ), -dot( ballp, [0,1,0]
), 5 - dot(ballp,[0,0,1])];
       v21 := (v2 - ballv) / (-2) ;
       n1   :=  norm(v21);
       batAngle := v21 / n1;
       z := (n1- dot(batAngle, [1,0,0])*4) / dot(batAngle, [0,0,1]);
       v := ballv - [4,0,z];

 else
if n == 1
   v2  := [(-dot(ballp, [1,0,0] ) + 0.75 + 0.5 ), -dot( ballp, [0,1,0]
), 5 - dot(ballp,[0,0,1])];
       v21 := (v2 - ballv) / (-2) ;
       n1   :=  norm(v21);
       batAngle := v21 / n1;
       z := (n1- dot(batAngle, [1,0,0])*4) / dot(batAngle, [0,0,1]);
       v := ballv - [4,0,z];
  end;
end;
 serve  := false;
 hit    := true;
 mode   := "Wait";
 desiredBatP := batp;
 if n == 1
  estimatedBatV := v - [0,0,8] ;
 else
if n == 2
  estimatedBatV := v ;
 end;
end;
case "Panic!"
end;

    // Compute the desired position based on the computed "control" speed
    desiredBatP' = v;


    // Basic controller to actuate acceleration
    a = 15*(desiredBatP'-estimatedBatV)+60*(desiredBatP-batp);

    // Keep track of effect of acceleration to estimate actual bat speed
    estimatedBatV' = a;
end



   




class Kong(n) 
// Based on WiffWaff's speed-control player,aim for edge. low shots. Aggressive player.
 private
  name := "Kong";
  mode   := "Wait";
  bounced   := false;   // Tell whether the ball bounced or not
  serve := false;       // The Game class will set serve flag to true
  hit   := false;       // when it's your turn
  hs:="0";
  count := 0;
  ballv := [0,0,0];
  ballp := [0,0,0];
  batp  := [1.6,0,0.2];
  v := [0,0,0];     // Bat's speed
  a := [0,0,0];     // Bat's acceleration (computed by controller)
  estimatedBatV  := [0,0,0]; // Predicted result of acceleration
  estimatedBatV' := [0,0,0]; // Equated to computed acceleration signal
  desiredBatP  := [1.6*(-1)^n,0,0.2]; // Desired bat position (from derive)
  desiredBatP' := [0,0,0]; // Desired bat speed (from naive)
  batAngle   := [0,0,0.1];  // Normal vector of the bat's plane
  batAngle'  := [0,0,0];
  // Player(1) starts at [-1.6,0,0.2], Player(2) starts at [1.6,0,0.2]
  startPoint := [1.6*(-1)^n,0,0.2];
  v2     := [0,0,0]; // The output speed of the ball, which we desired
  v21     := [0,0,0];
  z   := 0;
  n1   := 0;
  t   := 0;
  t'  := 1;
  number := n;
 end
 number = n;
 startPoint = [1.6*(-1)^number,0,0.2];
 if mode ~= "Wait" && mode ~= "Prepare" && mode ~= "Hit"
   mode := "Panic!";
 end;
 t'  = 1;
 switch mode
  case "Wait"           // While waiting, moving the bat to starting point
   count   := 0;
   if n == 1
  v     = startPoint-batp;
   else
  v     = startPoint-batp;
   end;
   batAngle' = [0,0,0]-batAngle;
   hit := false;
   if serve == true
mode := "Prepare";
bounced := false;
   else
mode := "Wait";
   end;
  case "Prepare"         // Prepare to hit the ball
   if bounced == true     // After the ball has bounced,
                          // start moving the bat towards the ball
  v = (ballp-batp).*[0,30,0] + (ballp-batp).*[0,0,25] +
                (ballp-batp).*[25,0,0];
  if norm(batp - ballp)<0.08
  count := count+1;
  mode  := "Hit";
  end;
   end;
   // When the ball has bounced and it is at the highest position
  // if count > 0 && dot(ballv,[0,0,1]) < 0.1 && bounced == true
   // mode := "Hit"; // This player decide to hit.
  // end;
   if dot(ballp,[0,0,1]) < 0 && bounced == false
bounced := true;
   end;
   if(serve ~= true)
  mode := "Wait";
   end;
 case "Hit"       // Decide how you want hit the ball,
  if n == 2
    if dot(ballp,[0,1,0]) <= -0.30
    //v := [4.5,0.80,14.5];
      v := ballv - [6.5,-2,2];
      batAngle := [0.95,0.13,-0.25];end;
if (dot(ballp,[0,1,0]) > -0.30) && (dot(ballp,[0,1,0]) < 0.30)
    v := ballv - [6.5,-1,2];
    batAngle := [0.95,2,-0.25];end;
   if (dot(ballp,[0,1,0]) >= 0.30)
    // v := [4,-0.8,14.5];
    v := ballv - [6.5,2,2];
 batAngle := [0.95,0.05,-0.25];end;
  else
    if dot(ballp,[0,1,0]) <= -0.30
    //v := [4.5,0.80,14.5];
      v := ballv + [6.5,2,2];
      batAngle := [-0.95,0.13,-0.25];end;
    if (dot(ballp,[0,1,0]) > -0.30) && (dot(ballp,[0,1,0]) < 0.30)
    v := ballv + [6.5,-0.5,2];
    batAngle := [-0.95,2,-0.25];end;
    if (dot(ballp,[0,1,0]) >= 0.30)
    // v := [4,-0.8,14.5];
    v := ballv + [6.5,-2,2];
 batAngle := [-0.95,0.05,-0.25];end;
end;
  serve  := false;
  hit := true;
  mode   := "Wait";
  desiredBatP := startPoint;
  if n == 1
   estimatedBatV := v - [0,0,10];
  else
   estimatedBatV := v ;
  end;
 case "Panic!"
 end;
 
  // Compute the desired position based on the computed "control" speed
  desiredBatP' = v;
  // Basic controller to actuate acceleration
  a = 13*(desiredBatP'-estimatedBatV)+ 50*(desiredBatP-batp);
  // Keep track of effect of acceleration to estimate actual bat speed
  estimatedBatV' = a;
end


















class Ball ()
 private
  mode := "Fly";
  k_z  := [1,1,-0.99];       // Coefficient of restitution
  k2   := 1/6;               // Coefficient of the air resistance
  p    := [0,0,0.5];         // Position of the ball
  p'   := [5,1,-3];
  p''  := [0,0,0];
  _3D  := ["Sphere",[0,0,0.5],0.03,[1,1,1],[0,0,0]];
 end
 _3D = ["Sphere",p,0.03,[1,1,1],[0,0,0]];
 // Valid modes
 if mode ~= "Fly" && mode ~= "Bounce" && mode ~= "Freeze"
   mode := "Panic!";
 end;
 switch mode
  case "Fly"
   if dot(p,[0,0,1]) < 0 && dot(p',[0,0,1])< 0
    mode := "Bounce";
   else
    p'' = -k2 * norm(p') * p' + [0,0,-9.8];
   end;
  case "Bounce"
    p'   :=  p' .* k_z;    // Bouncing  will lose some energy
    mode := "Fly";
  case "Freeze"           // The ball becomes red to show what is going wrong
    p'  = [0,0,0]; p'' = [0,0,0];
    _3D = ["Sphere",p,0.03,[1,0,0],[0,0,0]];
  case "Panic!"
  end
end

class BatActuator(p1)   
 private
  p       := p1;
  p'      := [0,0,0];
  p''     := [0,0,0];
  angle   := [0,0,0];
  energy  := 0;
  energy' := 0;  
 end
  if norm(p') > 5
   p' := p'/norm(p') * 5 ;
  end;
  if norm(p'') > 100
   p'' := p''/norm(p'') * 100;
  end;
//  energy' = norm(p');
    energy' = sqrt(abs(norm(p')*norm(p'')))/2;
end

class Bat(n,p1)
 private
  p     := p1;
  p'    := [0,0,0];
  angle := [0,0,0.1];
  displayAngle := [0,0,0];
  mode  := "Run";
  _3D   := ["Cylinder",p1,[0.15,0.01],[0.1,0.1,0.1],[0,0,0.5]];
 end
 switch mode 
  case "Run"
   if n == 2
     displayAngle  = [0,dot(angle,[0,0,1])*(3.14/2)/norm(angle),
                      dot(angle,[0,1,0])*(3.14/2)/norm(angle)]+[0,0,3.14/2];
    _3D            = ["Cylinder",p+[0.05,0,0],[0.15,0.001],
                        [0.1,0.1,0.1],displayAngle];
   else
      displayAngle = [dot(angle,[0,0,1])*(3.14/2),0,
                    dot(angle,[0,1,0])*(3.14/2)]+[0,0,3.14/2];
     _3D           = ["Cylinder",p+[-0.05,0,0],[0.15,0.001],
                        [1,0.1,0.1],-1 * displayAngle];
 end;
  case "Rest"
    p'            = [0,0,0];
 _3D           = ["Box",p+[-0.05,0,0],[0.3,0.3,0.3],
                        [1,1,0.1],-1 * displayAngle];
 end
end


class Table()   // The table
 private
                // Table
 _3D := [["Box", [0,0,-0.05],[3,1.5,0.03],[0.1,0.1,1.0],[0,0,0]],
                // TableBases 1~4 
        ["Box", [-1.4,0.6,-0.3-0.04], [0.05,0.05,0.6], [0.8,0.8,0.8],[0,0,0]], 
        ["Box", [-1.4,-0.6,-0.3-0.04], [0.05,0.05,0.6], [0.8,0.8,0.8],[0,0,0]],
        ["Box", [1.4,-0.6,-0.3-0.04], [0.05,0.05,0.6], [0.8,0.8,0.8],[0,0,0]],
        ["Box", [1.4,0.6,-0.3-0.04], [0.05,0.05,0.6], [0.8,0.8,0.8],[0,0,0]],
          // Net
        ["Box", [0,0,0.125-0.02], [0.05,1.5,0.25], [0.2,0.8,0.2],[0,0,0]], 
                 // MiddleLine  
  ["Box", [0,0,0],[3,0.02,0.02-0.02],[1,1,1],[0,0,0]]]           
 end
end

class BallActuator()  // Calculate result of impact
  private
   mode:="Initialize";
   v1 := [0,0,0];      // Input ball speed
   v2 := [0,0,0];      // Output ball speed
   v3 := [0,0,0];      // Bat's speed during the impact
   angle := [0,0,0];   // Bat's normal vector
   done  := false;
   action := 0;
 end
  if mode ~= "Initialize" && mode ~= "Calculate" && mode ~= "Wait"
   mode := "Panic!";
  end;
 switch mode
  case "Initialize"
   done=false;
   if action == 1
    mode := "Calculate";
   end;
 case "Calculate"
  v2     := v1-dot(2.*(v1-v3),angle)*angle;
  action := 0;
  if action == 0
   mode := "Wait";
  end;
 case "Wait"
  done = true;
 case "Panic!"
 end
end

// Sample the velocity of the ball and feed back to the players.
class BallObserver()  
 private
  mode := "Sample";
  p  := [0,0,0];
  v  := [0,0,0];
  pp := [0,0,0];
  ap := [0,0,0];
  t  := 0;
  t' := 1;
 end
 t'=1;
 if mode ~= "Sample" && mode ~= "Estimate0" && mode ~= "Estimate1"
  mode := "Panic!";
 end;
 switch mode
   case "Sample"
    if t > 0
     pp  := p;
     t   := 0;
     mode:= "Estimate0"
    end;
   case "Estimate0"
 if t == 0.01   // Calculate the average speed
     ap   := p;
     mode := "Estimate1";
    end;
   case "Estimate1"
    v    := dot((ap-pp),[1,0,0])/0.01*[1,0,0]+dot((ap-pp),[0,0,1])/0.01*[0,0,1]+
        dot((ap-pp),[0,1,0])/0.01*[0,1,0];
    mode := "Sample";
    t    := 0;
   case "Panic!"
  end
end

class Referee()  // This class will monitors the whole process of the game.
 private
  mode:="Initialize";
  x := 0;x' := 0;
  z := 0;z' := 0;
  y := 0;
  t := 0;t' := 1;
  player1Score := 0;
  player2Score := 0;
  serveNumber  := 2;
  lastHit      := 0;
  reason       := "Nothing";
  checked      := false;    // For the net checking
  bounced      := false;
  restart      := 0;        // Tell the Game to restart
  acknowledged := 0;        // Check if the Game class has received 
                           //  the restart signal
  bounceTime   := 0;
  status       := "Normal"
 end
 if mode ~= "Initialize" && mode ~= "Player1Lost" && mode ~= "Player2Lost" 
    && mode ~= "SendMessage" && status ~= "Normal" && reason ~= "Nothing"
    && status ~= "Report" && reason ~= "BallOutOfBoundary"
 && reason ~= "BallBouncedTwice" && reason ~= "BallTouchNet"
  mode := "Panic!";
 end;
  t'=1;
  if z<0.05 && z'<0 && status == "Normal"  // Check if anyone fouls
   if (abs(y)>0.78||abs(x)>1.53) && status == "Normal"
    reason     := "BallOutOfBoundary";
    if bounced == false
     if x>0
      mode := "Player1Lost";
     else
      mode := "Player2Lost";
     end;
    else
     if bounced == "YesIn2"    // The ball has bounced in player2's court, 
      mode := "Player2Lost"     // and out of boundary now, so player2 lose.
     end;
     if bounced == "YesIn1"
      mode := "Player1Lost";
     end;
    end;
    status := "Report";
   end;
   if(abs(y)<0.78 && abs(x)<1.53) && bounced ~= false  
      && t>(bounceTime+0.1) && status=="Normal"
 // The ball has bounced twice in player2's court  
    if bounced == "YesIn2" && x > 0 
     mode   := "Player2Lost";
     reason := "BallBouncedTwice";
  bounceTime := t;
    end;
 // The ball has bounced twice in player1's court
    if bounced == "YesIn1" && x < 0 
     mode   := "Player1Lost";
     reason := "BallBouncedTwice";
  bounceTime := t;
    end;
   end;
   if x<0 && x>-1.5 && bounced == false && status == "Normal"
    bounced    := "YesIn1";
    bounceTime := t;
   end;
   if x>=0 && x<1.5 && bounced == false && status == "Normal"
    bounced    := "YesIn2";
    bounceTime := t;
   end;
 end;




 if bounced == "YesIn1" && x>0 && status == "Normal"
  bounced := false
 end;
 if bounced == "YesIn2" && x<=0 && status == "Normal"
  bounced := false
 end;
  // Time to check if the ball touches the net
 if abs(x)<0.025 && t>0.1 && checked == false && status == "Normal"   
  if z<0.25
    if x'>0
     mode   := "Player1Lost";
    else
     mode   := "Player2Lost"
    end;
    reason  := "BallTouchNet";
    checked := true;
  end;
 end;
switch mode
 case "Initialize"
 case "Player1Lost"
  player2Score := player2Score+1;
  mode := "SendMessage";
 case "Player2Lost"
  player1Score := player1Score+1;
  mode := "SendMessage";
 case "SendMessage"
  t := 0; // Wait until the Game class gets the restart signal
  restart := 1;
  if acknowledged == 1
    mode := "Initialize";
    acknowledged := 0;
    restart := 0;
    status  := "Normal";
    checked := false;
    bounced := false;
  end;
  case "Panic!"
 end
end

/**
* The parent of all the other classes, who controls the
* whole process of the game.
**/
class Game (name1, name2)
 private
  ball    := create Ball ();
  ballob  := create BallObserver();
  ballActuator:= create BallActuator();
  batActuator1 := create BatActuator([-1.6,0,0.2]);
  batActuator2 := create BatActuator([1.6,0,0.2]);
  player1 := create WiffWaff(1);
  player2 := create WiffWaff(2);
  bat1    := create Bat(1,[-1.6,0,0.2]);
  bat2    := create Bat(2,[1.6,0,0.2]);
  table   := create Table();
  referee := create Referee();
  mode    := "Init";       // Player2 starts first
  player2Score := 0;
  player1Score := 0;
  serveNumber  := 2;
  t  := 0;
  t' := 1;
  finish := false;
  maxEnergy    := 18;
 _3D := [["Text",[-2.8,6.5,-4],1,[0.3,0,0],[1.7,0,0],""],
        		 ["Text",[2.8,6.5,-4],1,[0.3,0.3,0.3],[1.7,0,0],""],
        		 ["Text",[-1.8,6.5,-0.5],1,[0.6,0,0],[1.7,0,0],""],
        		 ["Text",[1.8,6.5,-0.5],1,[0.1,0.1,0.1],[1.7,0,0],""]];
 // WiffWaff := create WiffWaff(1);
 // ParadoX := create ParadoX(2);
 // Virtue := create Virtue(1);
 // PingPing := create PingPing(2);
 // Kong := create Kong(1);
 // Pisces := create Pisces(2);  
  
 end
 if finish == true
  for c=self.children
   terminate  c
  end;
  terminate self
 end;
   _3D = [["Text",[-2.8,6.5,-4],1,[0.9,0,0],[1.7,0,0],player1.name],
 		 ["Text",[2.8,6.5,-4],1,[0.1,0.1,0.1],[1.7,0,0],player2.name],
    	 ["Text",[-1.5,6.5,-5],1,[0.6,0,0],[1.7,0,0],player1Score],
		 ["Text",[4.5,6.5,-5],1,[0.1,0.1,0.1],[1.7,0,0],player2Score]];
  if mode ~= "Restart" && mode ~= "Player1Serve" && mode ~= "Player2Serve" 
  && mode ~= "Impact"  && mode ~= "Freeze" && mode ~= "ChangeSide" && mode ~= "Init"
  && mode ~= "Act"
   mode := "Panic!"
  end;
  t'=1;
  referee.x  = dot(ball.p,[1,0,0]);
  referee.x' = dot(ball.p',[1,0,0]);
  referee.z  = dot(ball.p,[0,0,1]);
  referee.z' = dot(ball.p',[0,0,1]);
  referee.y  = dot(ball.p,[0,1,0]);
  referee.serveNumber = serveNumber;
  player1Score  = referee.player1Score;
  player2Score  = referee.player2Score;
  ballob.p          = ball.p;
  player1.ballp     = ballob.p;
  player2.ballp     = ballob.p;  
  player1.ballv     = ballob.v;
  player2.ballv     = ballob.v;
  if bat1.mode ~= "Rest"
//   batActuator1.p' = player1.v;
   if (player1.mode=="Hit")
     batActuator1.p' := player1.v
   end;
   batActuator1.p'' = player1.a;
  end;
  if bat2.mode ~= "Rest"
//   batActuator2.p' = player2.v;
   if (player2.mode=="Hit")
     batActuator2.p' := player2.v
   end;
  batActuator2.p'' = player2.a;
  end;
  player1.batp  = bat1.p;
  player2.batp  = bat2.p;
  batActuator1.angle = player1.batAngle;
  batActuator2.angle = player2.batAngle;
  bat1.p  = batActuator1.p;
//  bat1.p' = batActuator1.p';
  bat2.p  = batActuator2.p;
//  bat2.p' = batActuator2.p';
  bat1.angle = batActuator1.angle;
  bat2.angle = batActuator2.angle;
  if batActuator1.energy > maxEnergy
     bat1.mode := "Rest";
 bat1.p'   := [0,0,0];
 batActuator1.p' = [0,0,0]; // Exception
// batActuator1.p'' = [0,0,0];
  end;
  if batActuator2.energy > maxEnergy
     bat2.mode := "Rest";
 bat2.p'   := [0,0,0];
 batActuator2.p' = [0,0,0]; // Exception
// batActuator2.p'' = [0,0,0];
  end; 
 switch mode
  case "Init"
  switch name1
    case "WiffWaff"
      player1 := create WiffWaff(1);
    case "Virtue"
      player1 := create Virtue(1);
	case "ParadoX"
	  player1 := create ParadoX(1);
    case "PingPing"
	  player1 := create PingPing(1);
    case "Kong"
      player1 := create Kong(1);
	case "Pisces"
	  player1 := create Pisces(1);
	case "XPTO"
	  player1 := create XPTO(1);
   case "Panther"
	  player1 := create Panther(1);	  
   end;
   switch name2
	case "WiffWaff"
      player2 := create WiffWaff(2);
    case "Virtue"
      player2 := create Virtue(2);
	case "ParadoX"
	  player2 := create ParadoX(2);
    case "PingPing"
	  player2 := create PingPing(2);
    case "Kong"
      player2 := create Kong(2);
	case "Pisces"
	  player2 := create Pisces(2);
	case "XPTO"
	  player2 := create XPTO(2);
   case "Panther"
	  player2 := create Panther(2);	  
   end;
  
   player1.n :=1;
   player2.n :=2;
   mode := "Player2Serve";
  case "Restart" // Put everything back to the starting point
   ball.p            := [0,0,0.5];
   ball.p'           := [5,1,-3];
   bat2.p            := [1.6,0,0.2];
   player2.batp      := [1.6,0,0.2];
   player2.desiredBatP := player2.batp; // New variables must also be updated
   player2.a         := [0,0,0];
   player2.estimatedBatV  := [0,0,0];
   player2.v         := [0,0,0];
   player2.batAngle  := [0.01,0,0];
   player2.bounced   := false;
   player2.ballp     := [1.6,0,0.2];
   bat1.p            := [-1.6,0,0.2];
   player1.batp      := [-1.6,0,0.2];
   player1.v         := [0,0,0];
   player1.batAngle  := [0.01,0,0];
   player1.bounced   := false;
   player1.batp      := [-1.6,0,0.2];
   player1.desiredBatP := player1.batp; // New variables must also be updated
   player1.a         := [0,0,0];
   player1.estimatedBatV  := [0,0,0];
   batActuator1.p    := [-1.6,0,0.2];
   batActuator2.p    := [1.6,0,0.2];
   serveNumber       := 2;
   referee.bounced      := false;
   referee.checked      := false;
   referee.acknowledged := 1;
   mode         := "Player2Serve";
   player1.mode := "Wait";
   player2.mode := "Wait";
  case "Player2Serve" // Player 2 is serving
   player1.serve = false;
   player2.serve =  true;
   if player2.hit == true && norm(bat2.p - ball.p) < 0.15 && bat2.mode ~= "Rest"
    mode := "Impact"
   end;
   if referee.restart == 1
    mode := "Freeze";
    t    := 0;
   end;
 case "Player1Serve" // Player 1 is serving
  player2.serve = false;
  player1.serve = true;
  if player1.hit == true && norm(bat1.p - ball.p) < 0.15 && bat1.mode ~= "Rest"
   mode := "Impact"
  end;
  if referee.restart == 1
   mode := "Freeze";
   t    := 0;
  end;
 case "Impact" // When one player hits the ball
  ballActuator.v1 := ball.p';
  if serveNumber == 2 // Give player2's data to bat actuator
   batActuator2.p' := player2.v;
//   batActuator2.p'' := player2.a;
   bat2.p'         := batActuator2.p';
   ballActuator.v3     := bat2.p';
   bat2.angle      := player2.batAngle;
   ballActuator.angle  := bat2.angle;
   ballActuator.action := 1; // Tell ball actuator to act
   referee.lastHit := 2;
   mode := "Act";
    if referee.restart == 1
      mode := "Freeze";
      t := 0;
    end;
  end;
  if serveNumber == 1 // Give player1's data to actuator
   batActuator1.p' := player1.v;
//   batActuator1.p'' := player1.a;
   bat1.p'         := batActuator1.p';
   ballActuator.v3     := bat1.p';
   bat1.angle      := player1.batAngle;
   ballActuator.angle  := bat1.angle;
   ballActuator.action := 1; // Tell ball Actuator to act
   referee.lastHit := 1;
   mode := "Act";
   if referee.restart == 1
    mode := "Freeze";
    t    := 0;
   end;
  end
 case "Act" // Wait till actuator finish
  if referee.restart == 1
   mode := "Freeze";
   t    := 0;
  end;
  if ballActuator.done == true
   ball.p'       := ballActuator.v2;
   ballActuator.mode := "Initialize";
   mode          := "ChangeSide";
  end;
 case "ChangeSide" // Change the serve number
  if referee.restart == 1
   mode := "Freeze";
   t    := 0;
  end;
  if serveNumber == 2 && dot(ball.p,[1,0,0]) >0 && referee.restart ~= 1
   serveNumber     := 1;
   mode            := "Player1Serve";
   player1.mode    := "Wait";
   player1.bounced := false;
  end;
  if serveNumber == 1 && dot(ball.p,[1,0,0]) <= 0 && referee.restart ~= 1
   serveNumber     := 2;
   mode            := "Player2Serve";
   player2.mode    := "Wait";
   player2.bounced := false;
  end; 
 // When someone fouls, showing what's going wrong for 1 second
 case "Freeze"          
   if t < 1
    ball.mode := "Freeze";
   else
    mode      := "Restart";
    ball.mode := "Fly";
   end;
 case "Panic!"
 end
end

class Main(simulator)
 private
  mode := "Initialize";
  name1 := "PingPing";
  name2 := "ParadoX";
  game := 0;
  t := 0 ;t' := 1;
 end
t' = 1;
switch mode
 case "Initialize"
  simulator.endTime := 81;
  game := create Game(name1, name2);
  mode := "Round1";
 case   "Round1"
   if t > 40
    game.finish := true;
	mode := "ChangeSide";
   	t := 0;
   end;
 case  "ChangeSide"
   game := create Game(name2, name1);
   mode := "Round2";
 case  "Round2"
     
 end
end
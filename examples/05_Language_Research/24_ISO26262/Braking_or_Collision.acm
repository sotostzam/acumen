// Two dimensional
// Authors: Walid Taha, Henrik Eriksson, and Adam Duraz
// 2015/02/27

// Key model features:
// - 2D model
// - Braking based on TTC (time-to-collision)
// - mu (friction coefficient, i.e. brake efficiency)
// - Braking target

model Main(simulator) =
initially
  // A scenario is defined by:
  // x1    Vehicle 1 initial position in x dimension (m)
  // y1    Vehicle 1 initial position in y dimension (m)
  // x1v   Vehicle 1 initial speed    in x dimension (m/s)
  // y1v   Vehicle 1 initial speed    in y dimension (m/s)
  // x2    Vehicle 2 initial position in x dimension (m)
  // y2    Vehicle 2 initial position in y dimension (m)
  // x2v   Vehicle 2 initial speed    in x dimension (m/s)
  // y2v   Vehicle 2 initial speed    in y dimension (m/s)
  // ba2   Vehicle 2 acceleration after t=10         (m/s2)
  // ttcpb Vehicle 1 pre-brake ttc threshold         (s)
  // ttcfb Vehicle 1 full-brake ttc threshold        (s)
  // pba   Vehicle 1 pre-brake deceleration          (m/s2)           
  // fba   Vehicle 1 full-brake deceleration         (m/s2)   
  // n     Scenario number
  s = create Scenario(
//|--------------------------------------------------------------------------------------------------------------------------------------------------------------
//| x1,  y1, x1v,          y1v, x2, y2,  x2v, y2v,            ba2,      ttcpb,      ttcfb,         pba,         fba,  i
//|--------------------------------------------------------------------------------------------------------------------------------------------------------------
//  0,  -75,   0, [10.0..10.0],  9,  0, -3.0,   0, [  3.0..  3.0], [2.0..2.5], [0.5..0.7], -[3.0..3.5], -[6.0..7.0],  1  // No collision, detection in turn
//  0,  -81,   0, [10.0..10.0],  9,  0, -3.0,   0, [  3.0..  3.0], [2.0..2.5], [0.5..0.7], -[3.0..3.5], -[6.0..7.0],  2  // No collision, detection late in turn
//  0,  -90,   0, [10.0..10.0],  9,  0, -3.0,   0, [  3.0..  3.0], [2.0..2.5], [0.5..0.7], -[3.0..3.5], -[6.0..7.0],  3  // No collision, detection after turn
//  0, -100,   0, [ 8.0.. 8.0],  9,  0, -3.0,   0, [ -1.0.. -1.0], [2.0..2.5], [0.5..0.7], -[3.0..3.5], -[6.0..7.0],  4  // No collision, decelerate after turn  <<< This scenario points to an issue with the braking logic
//  0,  -90,   0, [15.0..15.0],  9,  0, -3.0,   0, [  3.0..  3.0], [2.0..2.5], [0.5..0.7], -[3.0..3.5], -[6.0..7.0],  5  // Near collision, detection in turn
//  0,  -80,   0, [16.0..16.0],  9,  0, -3.0,   0, [-10.0..-10.0], [2.0..2.5], [0.5..0.7], -[3.0..3.5], -[6.0..7.0],  6  // Collision, stop after turn
//  0,  -50,   0, [21.0..21.0],  9,  0, -3.0,   0, [  3.0..  3.0], [2.0..2.5], [0.5..0.7], -[3.0..3.5], -[6.0..7.0],  7  // Collision in turn
//  0,  -60,   0, [10.0..10.0],  9,  0, -3.0,   0, [  0.0..  0.0], [2.0..2.5], [0.5..0.7], -[3.0..3.5], -[6.0..7.0],  8  // Slow collision
//  0,  -80,   0, [21.0..21.0],  9,  0, -3.0,   0, [  3.0..  3.0], [2.0..2.5], [0.5..0.7], -[3.0..3.5], -[6.0..7.0],  9  // Fast collision
  0, -100,   0, [20.0..24.0],  9,  0, -3.0,   0, [  3.0..  3.5], [2.0..2.5], [0.5..0.7], -[3.0..3.5], -[6.0..7.0],  10 // Fast collision, uncertain y1v and ba2
//|--------------------------------------------------------------------------------------------------------------------------------------------------------------
  ),
  _3DView = (),
  _3D = ()
always

  hypothesis "No collision" s.n <= 5 || s.state12 ~= "1-Post-Collision", // Requires time step 2^(-10) when s.n = 5

  simulator.endTime+ = 15,
  simulator.timeStep+ = 0.0009765625, // 2^(-10)
//  simulator.timeStep+ = 0.001953125, // 2^(-9)
//  simulator.timeStep+ = 0.00390625, // 2^(-8)
//  simulator.timeStep+ = 0.0078125, // 2^(-7)
//  simulator.timeStep+ = 0.015625, // 2^(-6)
//  simulator.timeStep+ = 0.03125, // 2^(-5)
//  simulator.timeStep+ = 0.0625, // 2^(-4)
//  simulator.timeStep+ = 0.05,
 
  _3D =
  ( Text                  // Collision state
    center = (-2.2,s.y2+3,1.6)
    size = 0.3
    color = yellow
    content = s.state12
  , Text                  // Vechicle 1 state
    center = (-2.2,s.y2+3,1.3)
    size = 0.3
    color = blue
    content = s.state1
  , Text                  // Vehicle 2 state
    center = (-2.2,s.y2+3,1.0)
    size = 0.3
    color = red
    content = s.state2
  , Box                    // Sheet behind state texts
    center = (-1.1,s.y2+3,1.38)
    size = (2.4,0.01,1)
  , Box                    // x-axis road
    center = (0,-1.5,-0.02)
    size = (1000,6,0.02)
    color = white * 0.93
  , Box                    // x-axis curb
    center = (0,-1.5,-0.025)
    size = (1000,9,0.02)
    color = white * 0.99
  , Box                    // x-axis road stripe
    center = (0,-1.5,-0.01)
    size = (1000,0.1,0.01)
    color = white
  , Box                    // y-axis road
    center = (-1.5,0,-0.02)
    size = (6,1000,0.02)
    color = white * 0.93
  , Box                    // y-axis curb
    center = (-1.5,0,-0.025)
    size = (9,1000,0.02)
    color = white * 0.99
  , Box                    // y-axis road stripe
    center = (-1.5,0,-0.01)
    size = (0.1,1000,1/20)
    color = white
    /* Sensor area and corners */
  , Box
    center = (s.x1,s.y1+s.vl1/2+s.sr/2,0)
    size = (s.sw,s.sr,0.05)   
    color = yellow
  , Sphere center = (s.x1+s.sw/2,s.ySensorFront,0) size = 0.1 color = yellow
  , Sphere center = (s.x1-s.sw/2,s.ySensorFront,0) size = 0.1 color = yellow
    /* Vehicle 1 */
  , Obj
    rotation = (0,0,-pi/2)
    center = (s.x1,s.y1+0.75,0.75)
    size = 100
    content = "truck"
  , Sphere center = (s.flx1,s.fly1,0) size = 0.1 color = blue
  , Sphere center = (s.frx1,s.fry1,0) size = 0.1 color = blue
  , Sphere center = (s.rlx1,s.rly1,0) size = 0.1 color = blue
  , Sphere center = (s.rrx1,s.rry1,0) size = 0.1 color = blue
    /* Vehicle 2 */
  , Obj
    rotation = (0,0,-s.rot2)
    center = (s.x2,s.y2,0.5)
    size = 2.1
    content = "car"
  , Sphere center = (s.flx2,s.fly2,0) size = 0.1 color = red
  , Sphere center = (s.frx2,s.fry2,0) size = 0.1 color = red
  , Sphere center = (s.rlx2,s.rly2,0) size = 0.1 color = red
  , Sphere center = (s.rrx2,s.rry2,0) size = 0.1 color = red
  ),
  _3DView = ((0,0,45), (0,0,0)) // Intersection from above
//  _3DView = ((-15,s.y2-15,15), (s.x2,s.y2,0))

model Scenario
  ( x1    // Vehicle 1 initial position in x dimension (m)
  , y1    // Vehicle 1 initial position in y dimension (m)
  , x1v   // Vehicle 1 initial speed    in x dimension (m/s)
  , y1v   // Vehicle 1 initial speed    in y dimension (m/s)
  , x2    // Vehicle 1 initial position in x dimension (m)
  , y2    // Vehicle 2 initial position in y dimension (m)
  , x2v   // Vehicle 2 initial speed    in x dimension (m/s)
  , y2v   // Vehicle 2 initial speed    in y dimension (m/s)
  , ba2   // Vehicle 2 acceleration in the Act mode    (m/s2)
  , ttcpb // Vehicle 1 pre-brake ttc threshold         (s)
  , ttcfb // Vehicle 1 full-brake ttc threshold        (s)
  , pba   // Vehicle 1 pre-brake deceleration          (m/s2)        
  , fba   // Vehicle 1 full-brake deceleration         (m/s2)
  , n     // Scenario number
  ) =
initially

  /* Vehicle 1 */
 
  state1 = "0-Cruise",
  m1 = 20000,
  x1' = x1v, x1'' = 0,
  y1' = y1v, y1'' = 0,
  vw1 = 2, vl1 = 11,    // Width and length
  flx1 = 0, fly1 = 0,   // Front left corner
  frx1 = 0, fry1 = 0,   // Front right corner
  rlx1 = 0, rly1 = 0,   // Rear left corner
  rrx1 = 0, rry1 = 0,   // Rear right corner
  mu    =  0.95,        // Brake efficiency            %/100
  pcb   =  0,           // Post-collision deceleration m/s2
  sr = 50, sw = 2,      // Sensor range and width
 
  /* Vehicle 2 */
 
  state2 = "0-Pre-Turn",
  m2 = 1500,
  x2' = x2v, x2'' = 0,
  y2' = y2v, y2'' = 0,
  vw2 = 2, vl2 = 4.5,  // Width and length
  radius = 3,          // Turn radius
  rot2 = 0, rot2' = 0, // Rotation
  // Front left corner
  flx2 = x2 - 2/2 * sin(0) - 4.5/2 * cos(0),
  fly2 = y2 - 2/2 * cos(0) + 4.5/2 * sin(0),
  // Front right corner
  frx2 = x2 + 2/2 * sin(0) - 4.5/2 * cos(0),
  fry2 = y2 + 2/2 * cos(0) + 4.5/2 * sin(0),
  // Rear left corner
  rlx2 = x2 - 2/2 * sin(0) + 4.5/2 * cos(0),
  rly2 = y2 - 2/2 * cos(0) - 4.5/2 * sin(0),
  // Rear right corner
  rrx2 = x2 + 2/2 * sin(0) + 4.5/2 * cos(0),
  rry2 = y2 + 2/2 * cos(0) - 4.5/2 * sin(0),
  // End points (a,b), x-intercept and slope of the line 
  // segment definig either the left or rear side
  ax = x2 - 2/2 * sin(0) - 4.5/2 * cos(0), 
  ay = y2 - 2/2 * cos(0) + 4.5/2 * sin(0),
  bx = x2 - 2/2 * sin(0) + 4.5/2 * cos(0),
  by = y2 - 2/2 * cos(0) - 4.5/2 * sin(0),
  xIntercept = 0, slope = 0,

  /* Common */
 
  state12 = "0-Pre-Collision",
  c = 0.5, // Coefficient of restitution used in collision
  collision_delta_xv1 = 0, collision_delta_yv1 = 0, // Estimate of damage to Vehicle 1
  collision_delta_xv2 = 0, collision_delta_yv2 = 0, // Estimate of damage to Vehicle 2
  sense = false,                          // Sensor area intersects Vehicle 2 (approxmation)
  collide = false,                        // Vehicle 1 intersects Vehicle 2 (approxmation)
  lineSegmentDefinedBy = "leftSide",      // Either leftSide or rearSide side
  lineTilts = "right",
  sensorCornerAboveLine = false,          // Front of sensor area is above line segment defining Vehicle 2
  sensorFrontWithinLineSegmentXBounds = false,
  ySensorFront = y1 + 10/2 + 50,          // y coordinate of the front of the sensor area
  v1CornerAboveLine = false,              // Front of sensor area is above line segment defining Vehicle 2
  v1FrontWithinLineSegmentXBounds = false,
  v1Front = y1 + 10/2,                    // y coordinate of the front of the sensor area
  xdiff  = x1 - x2,   ydiff  = y1 - y2,   // Vehicle 1/2 position difference
  xvdiff = x1v - x2v, yvdiff = y1v - y2v, // Vehicle 1/2 speed difference
  distance = sqrt(  ((x1 - x2)*(x1 - x2)) // 2D distance between Vehicle 1 and 2
                  + ((y1 - y2)*(y1 - y2))),
  epsilon  = 0.001                        // Quantity close to 0
  
always

  xdiff    = x1  - x2, 
  ydiff    = y1  - y2,
  xvdiff   = x1' - x2',
  yvdiff   = y1' - y2',
  distance = sqrt((xdiff*xdiff)+(ydiff*ydiff)),

  match state12 with
  [ "1-Post-Collision" ->
    rot2' = 0,
    x1'' = 0,
    if (y1'>0) then y1'' = pcb else state1+ = "4-Stopped",
    x2'' = 0, y2'' = 0
  | "0-Pre-Collision" ->
 
    /* Collision detection and handling */
    if collide then
      x1'+ = (m1*x1' + m2*x2' + m2*c*(-xvdiff))/(m1 + m2),
      y1'+ = (m1*y1' + m2*y2' + m2*c*(-yvdiff))/(m1 + m2),
      x2'+ = (m1*x1' + m2*x2' + m1*c*( xvdiff))/(m1 + m2), 
      y2'+ = (m1*y1' + m2*y2' + m1*c*( yvdiff))/(m1 + m2),
      collision_delta_xv1+ = x1' - (m1*x1' + m2*x2' + m2*c*(-xvdiff))/(m1 + m2),
      collision_delta_yv1+ = y1' - (m1*y1' + m2*y2' + m2*c*(-yvdiff))/(m1 + m2),
      collision_delta_xv2+ = x2' - (m1*x1' + m2*x2' + m1*c*( xvdiff))/(m1 + m2),  
      collision_delta_yv2+ = y2' - (m1*y1' + m2*y2' + m1*c*( yvdiff))/(m1 + m2),    
      state12+ = "1-Post-Collision"
    noelse,
   
    /* Vehicle 1 */
    match state1 with
    [ "0-Cruise" ->
      x1' = 0, y1' = y1v,
      if sense then state1+ = "1-Sense" noelse
    | "1-Sense" ->
      // Activating Pre-braking
      if (abs(yvdiff) > epsilon && (-ydiff)<ttcpb*yvdiff) then 
        state1+ = "2-Pre-Brake" 
      else (
        x1' = 0,
        y1'' = 0
      )
    | "2-Pre-Brake" ->
      // Activating Full Braking
      if (abs(yvdiff) > epsilon && (-ydiff)<ttcfb*yvdiff) then
        state1+ = "3-Brake"
      else (
        if (y1' > 0) then 
          x1' = 0,
          y1'' = pba*mu
        else
          state1+ = "4-Stopped"
      )
    | "3-Brake" ->
      if (y1' > 0) then 
        x1' = 0,
        y1'' = fba*mu
      else
        state1+ = "4-Stopped"
    | "4-Stopped" ->
      x1' = 0, y1' = 0
    ],

    /* Vehicle 2 */
    match state2 with
    [ "0-Pre-Turn" ->
      if (x2-vl2/2 > radius) then 
        rot2' = 0,
        x2' = x2v,
        y2' = y2v
      else
        state2+ = "1-Turn"
    | "1-Turn" ->
      if (rot2 < pi/2) then 
        rot2' = 1,
        x2'' = radius - x2,
        y2'' = radius - y2
      else
        state2+ = "2-Post-Turn"
    | "2-Post-Turn" ->
      if (y2 < 10) then
        rot2' = 0,
        x2' = 0,
        y2'' = 0
      else
        state2+ = "3-Act"
    | "3-Act" ->
      if (y2' > 0) then 
        rot2' = 0,
        x2' = 0,
        y2'' = ba2
      else
        state2+ = "4-Stopped"
    | "4-Stopped" ->
      rot2' = 0,
      x2' = 0, y2' = 0
    ]

  ],

  /* Detect when front right corner of sensor area crosses the 
   * line segment defined by either the rear or left side of 
   * Vehicle 2, or when its rear left corner is inside sensor area. */
  sense = (sensorFrontWithinLineSegmentXBounds && sensorCornerAboveLine) 
       || (ySensorFront >= rly2 && -sw/2 <= rlx2 && rlx2 <= sw/2),
  ySensorFront = y1 + vl1/2 + sr,
  sensorFrontWithinLineSegmentXBounds = ax <= sw/2 && bx >= -sw/2,

  /* Detect when front right corner of Vehicle 1 crosses the 
   * line segment defined by either the rear or left side of 
   * Vehicle 2, or when its rear left corner is inside Vehicle 1. */
  collide = (v1FrontWithinLineSegmentXBounds && v1CornerAboveLine) 
         || (v1Front >= rly2 && -vw1/2 <= rlx2 && rlx2 <= vw1/2),
  v1Front = y1 + vl1/2,
  v1FrontWithinLineSegmentXBounds = ax <= vw1/2 && bx >= -vw1/2,

  match lineSegmentDefinedBy with
  [ "leftSide" ->
    if (sw/2 <= rlx2) then
      ax = flx2, ay = fly2, bx = rlx2, by = rly2
    else
      lineSegmentDefinedBy+ = "rearSide"
  | "rearSide" ->
    ax = rlx2, ay = rly2, bx = rrx2, by = rry2
  ],
  // aboveLine = ySensorFront >= slope * sw/2 + xIntercept
  // slope = (ay - by) / (ax - bx), xIntercept = ay - slope * ax,
  match lineTilts with
  [ "right" ->
    sensorCornerAboveLine = ySensorFront*(ax - bx) 
                          < (ay - by)*sw/2 + (ay*(ax - bx) - (ay - by)*ax),
    v1CornerAboveLine     = v1Front*(ax - bx) 
                          < (ay - by)*vw1/2 + (ay*(ax - bx) - (ay - by)*ax),
    if (ax >= bx) then lineTilts+ = "left" noelse
  | "left" ->
    sensorCornerAboveLine = ySensorFront*(ax - bx) 
                         >= (ay - by)*sw/2 + (ay*(ax - bx) - (ay - by)*ax),
    v1CornerAboveLine     = v1Front*(ax - bx) 
                         >= (ay - by)*vw1/2 + (ay*(ax - bx) - (ay - by)*ax)
  ],

  /* Vehicle 1 and 2 boundaries */

  flx1 = x1 - vw1/2, fly1 = y1 + vl1/2,
  frx1 = x1 + vw1/2, fry1 = y1 + vl1/2,
  rlx1 = x1 - vw1/2, rly1 = y1 - vl1/2,
  rrx1 = x1 + vw1/2, rry1 = y1 - vl1/2,

  flx2 = x2 - vw2/2 * sin(rot2) - vl2/2 * cos(rot2),
  fly2 = y2 - vw2/2 * cos(rot2) + vl2/2 * sin(rot2),
  frx2 = x2 + vw2/2 * sin(rot2) - vl2/2 * cos(rot2),
  fry2 = y2 + vw2/2 * cos(rot2) + vl2/2 * sin(rot2),
  rlx2 = x2 - vw2/2 * sin(rot2) + vl2/2 * cos(rot2),
  rly2 = y2 - vw2/2 * cos(rot2) - vl2/2 * sin(rot2),
  rrx2 = x2 + vw2/2 * sin(rot2) + vl2/2 * cos(rot2),
  rry2 = y2 + vw2/2 * cos(rot2) - vl2/2 * sin(rot2)

// Model   :  2013_hh_T4.acm.  Practice game (3-D Ping Pong) 
// Author  :  Yingfu Zeng, Walid Taha, Xu Fei
// Date    :  2012/02/11
// Revision:  2013/02/06 New syntax for assignments (= and :=)
// Ideas   :  Bat has no mass.  Focus is on: Impact,  
//            problem decomposition, and systems modeling
// License:   BSD, GPL(V2), or other by agreement with Walid Taha

/* 
   Has error with semantic 2014
   Works with semantic 2013
   Has bug with semantic 2012
*/

#semantics "2013 Reference"

class Pawanism(n,maxA)
  private
    name      := "Pawanism";
    varX      := 0;
    varZ      := 0;
    mode      := "Wait";   // Initial mode is to Wait
    bounced   := false;    // Has the ball bounced?
    myServe   := false;    // Your turn to serve?  (set by Parent)
    starting  := false;    // Your turn to start the ball? (set by Parent)
    v_ball    := [0,0,0];      // Ball velocity (set by Parent)
    p_ball    := [0,0,0];      // Ball position (set by Parent)
    p_bat     := [1.6*(-1)^n,0,0.2];  // Bat  position (set by Parent)
    v         := [0,0,0];      // Bat velocity
    v'        := [0,0,0];      // Bat accerleration
    
    // The y position and velocity in z axis player can set to start the ball
    yS        := 0.25*(-1)^n;
    zp        := 3;
    pH        := [0,0,0];  // Heightest point of my start ball
    
    angle_bat  := [0,0,0.001];  // Normal vector of the bat's plane
    angle_bat' := [0,0,0];
    a_desired  := [0.9471*(-1)^(n+1),0,0.4];
    v_desired  := [1.6*(1)^n,0,1.2];
       
    // local timer
    t    := 0;
    t'   := 1;
 
    // These coefficients are needed for prediction of ball movement
    // Coefficient of restitution
    k_z := [1.0, 1.0, -0.99];
    // Coeffiecent of air resistance
    k_a := -1/6;
    // Ball acceleration (predicted)
    a1_predicted  := [0.0, 0.0, -9.8];
    a2_predicted  := [0.0, 0.0, -9.8];
    // First prediction poit: time, position, speed
    // When ball hits the table
    t1_predicted  := 0;
    p1_predicted  := [0, 0, 0];
    v1_predicted  := [0, 0, 0];
 
    // Second prediction point: time, position, speed
    // The maximum point of the second parabola
    t2_predicted  := 0;
    p2_predicted  := [0, 0, 0];
    v2_predicted  := [0, 0, 0];

    doneOnce   := false;
    // Time for accelerating
    ta         := 0;
    // Time for decelerating
    td         := 0;
    // Unit vector of direction
    u          := [1,0,0];
    // Distance between goal point and batp
    d_ballBat  := 0;
    // Prediction pointers (for debugging)
    _3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],
           ["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];

    // Spherical coordinate system
    r      := norm([1.6,0.1,0.2]);   
    r'     := 0;                     r''     := 0;
    alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
    alpha' := 0;                     alpha'' := 0;
    theta  := atan(1.6*(-1)^n/0.1);  
    theta' := 0;                     theta'' := 0;
    x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
    y  := 0.1;          y' := 0;     y''     := 0;
    z  := 0.2;          z' := 0;     z''     := 0;
  end
  
  if mode <> "Wait" && mode <> "Prepare" && mode <> "Startball" && mode <> "Reset"
     mode := "Panic!";
  end;
  
  t'  = 1;   // Rate for local timer
  // pH is the hightest from my start ball(easy to calculate from y and zp)   
  pH :=  [1.5 * (-1)^n, yS, let t = abs(zp/(-9.8 +  k_a*(zp)^2));
                              a = -9.8 +  k_a*(zp)^2 in 
                    zp*t + 0.5 * (a)*t^2 end];
  switch mode
    case "Wait" // Waiting for your serve, moving the bat to start point
      v'  = ([1.6*(-1)^n,0,0.4] - p_bat) * 20 + 10 * ([0,0,0]- v);
      t   := 0;
      t1_predicted  := 0;
      t2_predicted  := 0; 
      p2_predicted  := [0,0,0];
      doneOnce      := false;
      angle_bat'     = 2*([0,0,0] - angle_bat);
      if myServe == true && starting == false
        mode := "Prepare";
      end;
      // Calculate how to get to goal point(slightly behind and below pH)
      if myServe == true && starting == true 
        t  := 0;  
        d_ballBat := norm(p_bat - pH);
        u  := (pH + [0.07*(-1)^n,0,-0.13] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.13] - p_bat);
        ta := let d_ballBat = norm(p_bat - pH) in sqrt(2 * (d_ballBat / 2) / maxA) end;
        mode := "Startball";
      end;
    case "Startball" // Start the ball as I wanted
        _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
                ["Sphere",pH,0.02,[0,100,200],[0,0,0]]];
        
        // Path planning, first half distance fully accelerate the other 
        // half fully decelerate
        a_desired = [0.9471*(-1)^(n+1),(-1)^(n+1)*0.3,0.4];

         if(t < ta)
          v' = maxA* u;
          angle_bat' = (a_desired - angle_bat)/ta;
         // angle_bat = [0.9471*(-1)^(n+1),0,0.7];     
        else if (t>=ta && t<2*ta)
          v' = -maxA * u;          
          angle_bat = a_desired;
        else if (norm(p_ball - p_bat)>0.3)
          v' =5*([0,0,0]-v);
        // Prepare to hit the ball
        else if (norm(p_ball - p_bat)<0.3)
          v' = [(-1)^(n+1)*5-v(0),0,8-v(2)];
          ta := 0;      
        end;
        end;
        end;
      end;
    case "Prepare"    // Prepare to hit the ball 
      //Do predict, and move pat towards the second predict point
      // Bouncing condition
      if (p_ball(2)) < 0 && bounced == false
        bounced := true;
      end;
      if bounced == true
        p1_predicted  = p_ball;
        v1_predicted  = v_ball;
        t1_predicted  = 0;
        a_desired = [0.9471*(-1)^(n+1),(-1)^(n+1)*0.25*atan(p1_predicted(1)/p1_predicted(0)) + (-1)^(n+1)*atan(v1_predicted(1)/v1_predicted(0)),0.4];
      else
        // Calculating first prediction point
        // Linearized air resistance
        a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball
        // 1/a in z direction
        t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2))      // -v0
                       - sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));
        p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);
        v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;
        // Check if ball is going out of bounds
        // We can predict this before it actually happens
        // This actually can decrease power consuption in some cases.
        if t > 0.2*abs(t1_predicted)
          if (p1_predicted(0))*(-1)^n > 1.55 || (p1_predicted(0))*(-1)^n < 0.1   
             || abs((p1_predicted(1))) > 0.78
            mode    := "Wait";
            myServe := false;
          end;
        end;
      end;

      // Predict the goal point to prepare hit the ball(only do once per turn)
      if (t1_predicted < 0.15 && t1_predicted <> 0) && 
         ((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&
         doneOnce == false
      // Calculating second prediction point
      // Linearized air resistance
      a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;
      t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));
      p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted * (t2_predicted^2);
      v2_predicted = p1_predicted + a2_predicted * t2_predicted;
      doneOnce    := true;
      // First move back a bit
      // Save 0.05 sec for hit the ball with calculated velocity and angle
      t2_predicted := t2_predicted - 0.05;
      t  := 0;
      ta := t2_predicted/2;
      u  := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      end;
      _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
              ["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]];
      
    if doneOnce == false
      v'  = ([1.6*(-1)^n,0,0.4]-p_bat) * 7 + 2 * ([0,0,0]- v);
    end;
    // Path planning, first move to p2, then wait to hit the ball
    if doneOnce == true
      ta := sqrt(2* (d_ballBat/2)/maxA);
      angle_bat' = (a_desired - angle_bat)/ta;
      //angle_bat = a_desired;
      if(t < ta)
        
        v' = maxA* u;
       

      else if (t>=ta && t<2*ta)
        v' = -maxA * u;
      else if (norm(p_ball - p_bat)>0.2)
        v' =10*([0,0,0]-v);
      // Prepare to hit the ball
      else if (norm(p_ball - p_bat)<0.2)
        varX = 50*(abs(p_ball(0)))-norm(v_ball)*15;
        varZ = varX;     
        v' = [(-1)^(n+1)*varX-v(0),0,varZ-v(2)];
        ta = 0;
      end;
      end;
      end;
      end;
    end;
    case "Reset"  // Reset the intermediate variables to its initial value
      p_bat := [1.6*(-1)^n,0,0.2];
      r      := norm([1.6,0.1,0.2]);   
      r'     := 0;                     r''     := 0;
      alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
      alpha' := 0;                     alpha'' := 0;
      theta  := atan(1.6*(-1)^n/0.1);  
      theta' := 0;                     theta'' := 0;
      x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
      y  := 0.1;          y' := 0;     y''     := 0;
      z  := 0.2;          z' := 0;     z''     := 0;
      v := [0,0,0];       v' := [0,0,0];
      mode := "Wait";
    case "Panic!"
  end;
  x'' = (v'(0));
  y'' = (v'(1));
  z'' = (v'(2));
 
  r'' = (4*(x*x+y*y+z*z)*(x*x''+x'*x'+y*y''+y'*y'+z*z''+z'*z')-4*(x*x'+y*y'+z*z')*(x*x'+y*y'+z*z'))/(4*sqrt((x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)));
  alpha '' = (-4*z*(-x*z*x'+x*x*z'+y*(y*z'-z*y'))*(-x*z*x'+x*x*z'+y*(y*z'-z*y'))-(x*x+y*y)*(-8*z'*(x*x+y*y+z*z)*(x*x'+y*y'+z*z')+12*z*(x*x'+y*y'+z*z')*(x*x'+y*y'+z*z')-4*z*(x*x+y*y+z*z)*(x*x''+x'*x'+y*y''+y'*y'+z*z''+z'*z')+4*z''*(x*x+y*y+z*z)*(x*x+y*y+z*z)))/(4*((x*x+y*y)/(x*x+y*y+z*z)*sqrt((x*x+y*y)/(x*x+y*y+z*z)))*sqrt((x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)));
  theta'' = (-1)^(n)*(x*(-x*y*(2*x'*x'+y*y''-2*y'*y')+x*x*(y*x''+2*x'*y')+y*y*(-2*x'*y'+y*x'')+x*x*x*(-y'')))/(sqrt(x*x)*(x*x+y*y)*(x*x+y*y));
 
end

class Dexter(n,maxA)
private
name := "Dexter";
mode := "Wait"; // Initial mode is to Wait
bounced := false; // Has the ball bounced?
myServe := false; // Your turn to serve? (set by Parent)
starting := false; // Your turn to start the ball? (set by Parent)
v_ball := [0,0,0]; // Ball velocity (set by Parent)
p_ball := [0,0,0]; // Ball position (set by Parent)
p_bat := [1.6*(-1)^n,0,0.2]; // Bat position (set by Parent)
v := [2.828,0.5,1.414]; // Bat velocity
v' := [0.5,0.5,-0.866]; // Bat accerleration
// The y position and velocity in z axis player can set to start the ball
yS := 0.435*(-1)^n;
zp := 4;
pH := [0,0,0]; // Heightest point of my start ball
angle_bat := [0.235,0.5,-0.866]; // Normal vector of the bat's plane
angle_bat' := [0,0,0];
a_desired := [0.9471*(-1)^(n+1),0,0.4];
v_desired := [1.6*(1)^n,0,1.2];
// local timer
t := 0;
t' := 1;
// These coefficients are needed for prediction of ball movement
// Coefficient of restitution
k_z := [1.0, 1.0, -0.99];
// Coeffiecent of air resistance
k_a := -1/6;
// Ball acceleration (predicted)
a1_predicted := [0.0, 0.0, -9.8];
a2_predicted := [0.0, 0.0, -9.8];
// First prediction poit: time, position, speed
// When ball hits the table
t1_predicted := 0;
p1_predicted := [0, 0, 0];
v1_predicted := [0, 0, 0];
// Second prediction point: time, position, speed
// The maximum point of the second parabola
t2_predicted := 0;
p2_predicted := [0, 0, 0];
v2_predicted := [0, 0, 0];
doneOnce := false;
// Time for accelerating
ta := 0;
// Time for decelerating
td := 0;
// Unit vector of direction
u := [1,0,0];
// Distance between goal point and batp
d_ballBat := 0;
// Prediction pointers (for debugging)
_3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],
["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];
// Spherical coordinate system
r := norm([1.6,0.1,0.2]);
r' := 0; r'' := 0;
alpha := acos(0.2/norm([-1.6,0.1,0.2]));
alpha' := 0; alpha'' := 0;
theta := atan(1.6*(-1)^n/0.1);
theta' := 0; theta'' := 0;
x := 1.6*(-1)^n; x' := 0; x'' := 0;
y := 0.1; y' := 0; y'' := 0;
z := 0.2; z' := 0; z'' := 0;
end
if mode <> "Wait" && mode <> "Prepare" && mode <> "Startball" && mode <> "Reset"
mode := "Panic!";
end;
t' = 1; // Rate for local timer
// pH is the hightest from my start ball(easy to calculate from y and zp)
pH := [1.5 * (-1)^n, yS, let t = abs(zp/(-9.8 + k_a*(zp)^2));
a = -9.8 + k_a*(zp)^2 in
zp*t + 0.5 * (a)*t^2 end];
switch mode
case "Wait" // Waiting for your serve, moving the bat to start point
v' = ([1.6*(-1)^n,0,0.4] - p_bat) * 7 + 2 * ([0,0,0]- v);
t := 0;
t1_predicted := 0;
t2_predicted := 0;
p2_predicted := [0,0,0];
doneOnce := false;
angle_bat' = 2*([0,0,0] - angle_bat);
if myServe == true && starting == false
mode := "Prepare";
end;
// Calculate how to get to goal point(slightly behind and below pH)
if myServe == true && starting == true
t := 0;
d_ballBat := norm(p_bat - pH);
u := (pH + [0.07*(-1)^n,0,-0.13] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.13] - p_bat);
ta := let d_ballBat = norm(p_bat - pH) in sqrt(2 * (d_ballBat / 2) / maxA) end;
mode := "Startball";
end;
case "Startball" // Start the ball as I wanted
_3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
["Sphere",pH,0.02,[0,100,200],[0,0,0]]];
// Path planning, first half distance fully accelerate the other
// half fully decelerate
if(t < ta)
v' = maxA* u;
angle_bat = [0.9471*(-1)^(n+1),0,0.7];
else if (t>=ta && t<2*ta)
v' = -maxA * u;
else if (norm(p_ball - p_bat)>0.25)
v' =10*([0,0,0]-v);
// Prepare to hit the ball
else if (norm(p_ball - p_bat)<0.25)
v' = [-7 * (p_ball(0)),0,7];
ta := 0;
end;
end;
end;
end;
case "Prepare" // Prepare to hit the ball
//Do predict, and move pat towards the second predict point
// Bouncing condition
if (p_ball(2)) < 0 && bounced == false
bounced := true;
end;
if bounced == true
p1_predicted = p_ball;
v1_predicted = v_ball;
t1_predicted = 0;
else
// Calculating first prediction point
// Linearized air resistance
a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball
// 1/a in z direction
t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2)) // -v0
- sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));
p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);
v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;
// Check if ball is going out of bounds
// We can predict this before it actually happens
// This actually can decrease power consuption in some cases.
if t > 0.2*abs(t1_predicted)
if (p1_predicted(0))*(-1)^n > 1.55 || (p1_predicted(0))*(-1)^n < 0
|| abs((p1_predicted(1))) > 0.78
mode := "Wait";
myServe := false;
end;
end;
end;
// Predict the goal point to prepare hit the ball(only do once per turn)
if (t1_predicted < 0.15 && t1_predicted <> 0) &&
((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&
doneOnce == false
// Calculating second prediction point
// Linearized air resistance
a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;
t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));
p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted *
(t2_predicted^2);
v2_predicted = p1_predicted + a2_predicted * t2_predicted;
doneOnce := true;
// First move back a bit
// Save 0.05 sec for hit the ball with calculated velocity and angle
t2_predicted := t2_predicted - 0.05;
t := 0;
ta := t2_predicted/2;
u := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
end;
_3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]];
if doneOnce == false
v' = ([1.6*(-1)^n,0,0.4]-p_bat) * 7 + 2 * ([0,0,0]- v);
end;
// Path planning, first move to p2, then wait to hit the ball
if doneOnce == true
ta := sqrt(2* (d_ballBat/2)/maxA);
angle_bat = a_desired;
if(t < ta)
v' = maxA* u;
else if (t>=ta && t<2*ta)
v' = -maxA * u;
else if (norm(p_ball - p_bat)>0.2)
v' =5*([0,0,0]-v);
// Prepare to hit the ball
else if (norm(p_ball - p_bat)<0.2)
v' = [-30*(p_ball(0)),0,20];
ta = 0;
end;
end;
end;
end;
end;
case "Reset" // Reset the intermediate variables to its initial value
p_bat := [1.6*(-1)^n,0,0.2];
r := norm([1.6,0.1,0.2]);
r' := 0; r'' := 0;
alpha := acos(0.2/norm([-1.6,0.1,0.2]));
alpha' := 0; alpha'' := 0;
theta := atan(1.6*(-1)^n/0.1);
theta' := 0; theta'' := 0;
x := 1.6*(-1)^n; x' := 0; x'' := 0;
y := 0.1; y' := 0; y'' := 0;
z := 0.2; z' := 0; z'' := 0;
v := [0,0,0]; v' := [0,0,0];
mode := "Wait";
case "Panic!"
end;
x'' = (v'(0));
y'' = (v'(1));
z'' = (v'(2));

/*
r'' = 0; // Derive correct equation
alpha '' = 0; // Derive correct equation
theta '' = 0; // Derive correct equation
end
*/


 r''      = ((x'^2+y'^2+z'^2+x*x''+y*y''+z*z'')-(r'^2))/r; 

alpha''= ((z*r''-z''*r)/((r)*(x^2+y^2)^(1/2)))-((r'*alpha')/r)-(((x*x'+y*y')*alpha'))/(x^2+y^2);

theta'' =((x''*y-x*y'')-2*theta'*(x*x'+y*y'))/(x^2+y^2);

end


class Joshua(n,maxA)
  private
    name      := "Joshua";
    mode      := "Wait";   // Initial mode is to Wait
    bounced   := false;    // Has the ball bounced?
    myServe   := false;    // Your turn to serve?  (set by Parent)
    starting  := false;    // Your turn to start the ball? (set by Parent)
    v_ball    := [0,0,0];      // Ball velocity (set by Parent)
    p_ball    := [0,0,0];      // Ball position (set by Parent)
    p_bat     := [1.6*(-1)^n,0,0.2];  // Bat  position (set by Parent)
    v         := [0,0,0];      // Bat velocity
    v'        := [0,0,0];      // Bat accerleration
    
    // The y position and velocity in z axis player can set to start the ball
    yS        := 0.5*(-1)^n;
    zp        := 4;
    pH        := [0,0,0];  // Heightest point of my start ball
    
    angle_bat  := [0,0,0.001];  // Normal vector of the bat's plane
    angle_bat' := [0,0,0];
    a_desired  := [0.9471*(-1)^(n+1),0,0.4];
    a_d  := [0,0,0];
    v_desired  := [3*(1)^n,1,0];
       
    // local timer
    t    := 0;
    t'   := 1;
 
    // These coefficients are needed for prediction of ball movement
    // Coefficient of restitution
    k_z := [1.0, 1.0, -0.99];
    // Coeffiecent of air resistance
    k_a := -1/6;
    // Ball acceleration (predicted)
    a1_predicted  := [0.0, 0.0, -9.8];
    a2_predicted  := [0.0, 0.0, -9.8];
    // First prediction poit: time, position, speed
    // When ball hits the table
    t1_predicted  := 0;
    p1_predicted  := [0, 0, 0];
    v1_predicted  := [0, 0, 0];
 
    // Second prediction point: time, position, speed
    // The maximum point of the second parabola
    t2_predicted  := 0;
    p2_predicted  := [0, 0, 0];
    v2_predicted  := [0, 0, 0];


    doneOnce   := false;
    // Time for accelerating
    ta         := 0;
    // Time for decelerating
    td         := 0;
    // Unit vector of direction
    u          := [1,0,0];
    // Distance between goal point and batp
    d_ballBat  := 0;
    // Prediction pointers (for debugging)
    _3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],
           ["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];


    // Spherical coordinate system
    r      := norm([1.6,0.1,0.2]);   
    r'     := 0;                     r''     := 0;
    alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
    alpha' := 0;                     alpha'' := 0;
    theta  := atan(1.6*(-1)^n/0.1);  
    theta' := 0;                     theta'' := 0;
    x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
    y  := 0.1;          y' := 0;     y''     := 0;
    z  := 0.2;          z' := 0;     z''     := 0;
  end
  
  if mode <> "Wait" && mode <> "Prepare" && mode <> "Startball" && mode <> "Reset"
     mode := "Panic!";
  end;
  
  t'  = 1;   // Rate for local timer
  // pH is the hightest from my start ball(easy to calculate from y and zp)   
  pH :=  [1.5 * (-1)^n, yS, let t = abs(zp/(-9.8 +  k_a*(zp)^2));
                              a = -9.8 +  k_a*(zp)^2 in 
                    zp*t + 0.5 * (a)*t^2 end];
 switch mode
    case "Wait" // Waiting for your serve, moving the bat to start point
  
      v'  = ([(1.6*(-1)^n-p_bat(0)),0-p_bat(1),0.2-p_bat(2)] ) * 85 + 20 * ([0,0,0]- v);
  
      t   := 0;
      t1_predicted  := 0;
      t2_predicted  := 0; 
      p2_predicted  := [0,0,0];
      doneOnce      := false;
      angle_bat'     = 2*([0,0,0] - angle_bat);
      if myServe == true && starting == false
        mode := "Prepare";
      end;
      // Calculate how to get to goal point(slightly behind and below pH)
      if myServe == true && starting == true 
        t := 0;  
        d_ballBat := norm(p_bat - pH);
        u := (pH + [0.07*(-1)^n,0,-0.1] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.1] - p_bat);
        ta := let d_ballBat = norm(p_bat - pH) in sqrt(2* (d_ballBat / 2) / maxA) end;
        mode := "Startball";
      end;
    case "Startball" // Start the ball as I wanted
        _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
              ["Sphere",pH,0.02,[0,100,200],[0,0,0]]];
        
        // Path planning, first half distance fully accelerate the other 
        // half fully decelerate
        if starting == false
           mode := "Prepare";
        end;
        if(t < ta)
          v' = maxA* u;       
          angle_bat' = (a_desired - angle_bat)/ta; 
        else if (t>=ta && t<2*ta)
          v' = -maxA * u;
          angle_bat = a_desired+[0,pi/7*(-1)*(-1)^n,0]; 
        else if (norm(p_ball - p_bat)>0.2)
          v' =5*([0,0,0]-v);
        // Prepare to hit the ball
        else if (norm(p_ball - p_bat)<0.2)
            v' = [-10 * (p_ball(0)),0,5];
            ta := 0;    
        end;
        end;
        end;
      end;
    case "Prepare"    // Prepare to hit the ball and do the predict
      //Do predict, and move pat towards the second predict point
      // Bouncing condition
      if (p_ball(2)) < 0 && bounced == false
        bounced := true;
      end;
      if bounced == true
        p1_predicted  = p_ball;
        v1_predicted  = v_ball;
        t1_predicted  = 0;
      else
        // Calculating first prediction point
        // Linearized air resistance
        a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball
        // 1/a in z direction
        t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2))      // -v0
                       - sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));
        p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);
        v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;
        // Check if ball is going out of bounds
        // We can predict this before it actually happens
        // This actually can decrease power consuption in some cases.
        if t > 0.2*abs(t1_predicted)
          if (p1_predicted(0))*(-1)^n > 1.53 || (p1_predicted(0))*(-1)^n < 0.2   
             || abs((p1_predicted(1))) > 0.78
            mode    := "Wait";
            myServe := false;
          end;
          end;
      end;


      // Predict the goal point to prepare hit the ball(only do once per turn)
      if (t1_predicted < 0.15 && t1_predicted <> 0) && 
         ((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&
         doneOnce == false
      // Calculating second prediction point
      // Linearized air resistance
      a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;
         if abs(p1_predicted(0))>1
           t2_predicted = -0.6*/*abs(p1_predicted(1))*/(v1_predicted(2)) / (a2_predicted(2));
         else
           t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));
         end;
      p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted * (t2_predicted^2);
      v2_predicted = v1_predicted + a2_predicted * t2_predicted;
      doneOnce := true;
      // First move back a bit
      // Save 0.05 sec for hit the ball with calculated velocity and angle
      t2_predicted := t2_predicted - 0.05;
      t  := 0;
      ta := t2_predicted/2;
       if abs(p1_predicted(0))<0.2
       u=[0,0,0];
       else
      u := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      end;
      d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      end;
      _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
              ["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]];
      
    if doneOnce == false
      v'  = ([1.6*(-1)^n,0,0.4]-p_bat) * 5 + 5 * ([0,0,0]- v);
    end;
    // Path planning, first move to p2, then wait to hit the ball
    if doneOnce == true
      ta := sqrt(2* (d_ballBat/2)/maxA);
      if p2_predicted(2)>0.4
      
        a_d =[0,-p2_predicted(1)*pi/7,-p2_predicted(2)*pi/15]
      else
       a_d = [0,-p2_predicted(1)*pi/7,-v2_predicted(2)*pi/20];
      end;
       angle_bat' = (a_desired+ a_d - angle_bat)/ta;
      if (norm(p_ball - p_bat)>0.2)
      v'  = (p2_predicted + [0.2*(-1)^n,0,0] - p_bat) * 85 + 20 * ([0,0,0]- v);
      else if (norm(p_ball - p_bat)<0.2)
        if abs(p2_predicted(0))>1.5
        v' = -100*(v-1*[-0.9*abs(p2_predicted(0))*(p_ball(0)),(-0.3)^(n+1),2-v2_predicted(2)*pi/20]);
        else if abs(p2_predicted(0))>1.2
        v' = -100*(v-1*[-1.6*abs(p2_predicted(0))*(p_ball(0)),(-0.3)^(n+1),2-v2_predicted(2)*pi/20]);//+5*(0.5*v_desired-v);
        else
         v' = -100*(v-1*[-3*(p_ball(0)),(-0.3)^(n+1),2-v2_predicted(2)*pi/20]);
        end;
        ta = 0;
//     end;
      end;
      end;
      end;
    end;
    case "Reset"  // Reset the intermediate variables to its initial value
      p_bat := [1.6*(-1)^n,0,0.2];
      r      := norm([1.6,0.1,0.2]);   
      r'     := 0;                     r''     := 0;
      alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
      alpha' := 0;                     alpha'' := 0;
      theta  := atan(1.6*(-1)^n/0.1);  
      theta' := 0;                     theta'' := 0;
      x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
      y  := 0.1;          y' := 0;     y''     := 0;
      z  := 0.2;          z' := 0;     z''     := 0;
      v := [0,0,0];       v' := [0,0,0];
      mode := "Wait";
    case "Panic!"
  end;
  x'' = (v'(0));
  y'' = (v'(1));
  z'' = (v'(2));
  r''      = (2*x'^2 + 2*y'^2 + 2*z'^2 + 2*x*x'' + 2*y*y'' + 2*z*z'')/(2*(x^2 + y^2 + z^2)^(1/2)) 
              - (2*x*x' + 2*y*y' + 2*z*z')^2/(4*(x^2 + y^2 + z^2)^(3/2));
  alpha '' = -1 * (z''/r - (2*r'*z')/r^2 + (2*z*r'^2)/r^3 - (z*r'')/r^2)/(1 - z^2/r^2)^(1/2) 
             - ((z'/r - (z*r')/r^2)*((2*z*z')/r^2 - (2*z^2*r')/r^3))/(2*(1 - z^2/r^2)^(3/2));
  theta '' = (x''*y-x*y'')/(y^2+x^2)-(x'*y-x*y')*(2*y*y'+2*x*x')/((y^2+x^2)^2);

end

class TheAvengers(n,maxA)
  private
    name      := "Avengers";
    mode      := "Wait";   // Initial mode is to Wait
    bounced   := false;    // Has the ball bounced?
    myServe   := false;    // Your turn to serve?  (set by Parent)
    starting  := false;    // Your turn to start the ball? (set by Parent)
    v_ball    := [0,0,0];      // Ball velocity (set by Parent)
    p_ball    := [0,0,0];      // Ball position (set by Parent)
    p_bat     := [1.6*(-1)^n,0,0.2];  // Bat  position (set by Parent)
    v         := [0,0,0];      // Bat velocity
    v'        := [0,0,0];      // Bat accerleration
    
    // The y position and velocity in z axis player can set to start the ball
    yS        := 0.5*(-1)^n;
    zp        := 4;
    pH        := [0,0,0];  // Heightest point of my start ball
    
    angle_bat  := [0,0,0.001];  // Normal vector of the bat's plane
    angle_bat' := [0,0,0];
    a_desired  := [0.9471*(-1)^(n+1),0,0.4];
    v_desired  := [1.6*(1)^n,0,1.2];
       
    // local timer
    t    := 0;
    t'   := 1;
 
    // These coefficients are needed for prediction of ball movement
    // Coefficient of restitution
    k_z := [1.0, 1.0, -0.99];
    // Coeffiecent of air resistance
    k_a := -1/6;
    // Ball acceleration (predicted)
    a1_predicted  := [0.0, 0.0, -9.8];
    a2_predicted  := [0.0, 0.0, -9.8];
    // First prediction poit: time, position, speed
    // When ball hits the table
    t1_predicted  := 0;
    p1_predicted  := [0, 0, 0];
    v1_predicted  := [0, 0, 0];
 
    // Second prediction point: time, position, speed
    // The maximum point of the second parabola
    t2_predicted  := 0;
    p2_predicted  := [0, 0, 0];
    v2_predicted  := [0, 0, 0];

    doneOnce   := false;
    // Time for accelerating
    ta         := 0;
    // Time for decelerating
    td         := 0;
    // Unit vector of direction
    u          := [1,0,0];
    // Distance between goal point and batp
    d_ballBat  := 0;
    // Prediction pointers (for debugging)
    _3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],
           ["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];

    // Spherical coordinate system
    r      := norm([1.6,0.1,0.2]);   
    r'     := 0;                     r''     := 0;
    alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
    alpha' := 0;                     alpha'' := 0;
    theta  := atan(1.6*(-1)^n/0.1);  
    theta' := 0;                     theta'' := 0;
    x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
    y  := 0.1;          y' := 0;     y''     := 0;
    z  := 0.2;          z' := 0;     z''     := 0;
  end
  
  if mode <> "Wait" && mode <> "Prepare" && mode <> "Startball" && mode <> "Reset"
     mode := "Panic!";
  end;
  
  t'  = 1;   // Rate for local timer
  // pH is the hightest from my start ball(easy to calculate from y and zp)   
  pH :=  [1.5 * (-1)^n, yS, let t = abs(zp/(-9.8 +  k_a*(zp)^2));
                              a = -9.8 +  k_a*(zp)^2 in 
                    zp*t + 0.5 * (a)*t^2 end];
  switch mode
    case "Wait" // Waiting for your serve, moving the bat to start point
      v'  = ([1.6*(-1)^n,0,0.4] - p_bat) * 7 + 2 * ([0,0,0]- v);
      t   := 0;
      t1_predicted  := 0;
      t2_predicted  := 0; 
      p2_predicted  := [0,0,0];
      doneOnce      := false;
      angle_bat'     = 2*([0,0,0] - angle_bat);
      if myServe == true && starting == false
        mode := "Prepare";
      end;
      // Calculate how to get to goal point(slightly behind and below pH)
      if myServe == true && starting == true 
        t  := 0;  
        d_ballBat := norm(p_bat - pH);
        u  := (pH + [0.07*(-1)^n,0,-0.13] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.13] - p_bat);
        ta := let d_ballBat = norm(p_bat - pH) in sqrt(2 * (d_ballBat / 2) / maxA) end;
        mode := "Startball";
      end;
    case "Startball" // Start the ball as I wanted
        _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
                ["Sphere",pH,0.02,[0,100,200],[0,0,0]]];
        
        // Path planning, first half distance fully accelerate the other 
        // half fully decelerate
         if(t < ta)
          v' = maxA* u;
          angle_bat = [0.9471*(-1)^(n+1),0,0.7];     
        else if (t>=ta && t<2*ta)
          v' = -maxA * u;          
        else if (norm(p_ball - p_bat)>0.25)
          v' =10*([0,0,0]-v);
        // Prepare to hit the ball
        else if (norm(p_ball - p_bat)<0.25)
          v' = [-7 * (p_ball(0)),0,7];
          ta := 0;      
        end;
        end;
        end;
      end;
    case "Prepare"    // Prepare to hit the ball 
      //Do predict, and move pat towards the second predict point
      // Bouncing condition
      if (p_ball(2)) < 0 && bounced == false
        bounced := true;
      end;
      if bounced == true
        p1_predicted  = p_ball;
        v1_predicted  = v_ball;
        t1_predicted  = 0;
      else
        // Calculating first prediction point
        // Linearized air resistance
        a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball
        // 1/a in z direction
        t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2))      // -v0
                       - sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));
        p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);
        v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;
        // Check if ball is going out of bounds
        // We can predict this before it actually happens
        // This actually can decrease power consuption in some cases.
        if t > 0.2*abs(t1_predicted)
          if (p1_predicted(0))*(-1)^n > 1.55 || (p1_predicted(0))*(-1)^n < 0   
             || abs((p1_predicted(1))) > 0.78
            mode    := "Wait";
            myServe := false;
          end;
        end;
      end;

      // Predict the goal point to prepare hit the ball(only do once per turn)
      if (t1_predicted < 0.15 && t1_predicted <> 0) && 
         ((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&
         doneOnce == false
      // Calculating second prediction point
      // Linearized air resistance
      a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;
      t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));
      p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted * (t2_predicted^2);
      v2_predicted = p1_predicted + a2_predicted * t2_predicted;
      doneOnce    := true;
      // First move back a bit
      // Save 0.05 sec for hit the ball with calculated velocity and angle
      t2_predicted := t2_predicted - 0.05;
      t  := 0;
      ta := t2_predicted/2;
      u  := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      end;
      _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
              ["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]];
      
    if doneOnce == false
      v'  = ([1.6*(-1)^n,0,0.4]-p_bat) * 7 + 2 * ([0,0,0]- v);
    end;
    // Path planning, first move to p2, then wait to hit the ball
    if doneOnce == true
      ta := sqrt(2* (d_ballBat/2)/maxA);
      angle_bat = a_desired;
      if(t < ta)
        v' = maxA* u;
      else if (t>=ta && t<2*ta)
        v' = -maxA * u;
      else if (norm(p_ball - p_bat)>0.2)
        v' =5*([0,0,0]-v);
      // Prepare to hit the ball
      else if (norm(p_ball - p_bat)<0.2)
        v' = [-30*(p_ball(0)),0,20];
        ta = 0;
      end;
      end;
      end;
      end;
    end;
    case "Reset"  // Reset the intermediate variables to its initial value
      p_bat := [1.6*(-1)^n,0,0.2];
      r      := norm([1.6,0.1,0.2]);   
      r'     := 0;                     r''     := 0;
      alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
      alpha' := 0;                     alpha'' := 0;
      theta  := atan(1.6*(-1)^n/0.1);  
      theta' := 0;                     theta'' := 0;
      x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
      y  := 0.1;          y' := 0;     y''     := 0;
      z  := 0.2;          z' := 0;     z''     := 0;
      v := [0,0,0];       v' := [0,0,0];
      mode := "Wait";
    case "Panic!"
  end;
  x'' = (v'(0));
  y'' = (v'(1));
  z'' = (v'(2));
  
  r''      = ((x'^2+y'^2+z'^2+x*x''+y*y''+z*z'')/r)-((x*x'+y*y'+z*z')^2/r^3); // Derive correct equation
  alpha '' = -1*((z''/r)-((2*x*x'+2*y*y'+2*z*z')*z'/r^3)-(z*(x'^2+y'^2+z'^2+x*x''+y*y''+z*z'')/r^3) +(3*z*(x*x'+y*y'+z*z')^2/r^5))/((x^2+y^2)/r^2)^0.5 -(z*(x^2*z'-z*x*x'+y^2*z'-z*y*y')^2/((x^2+y^2)^1.5*r^4));
  theta '' = -1*(x*(y*(2*x'^2-2*y'^2)+y^2*y'')-x^2*(y*x''+2*y'*x')+x^3*y''-y^3*x''+2*y^2*x'*y')/((x^2+y^2)^2);

end


class LPD(n,maxA)
private
name := "PlayerLPD";
mode := "Wait"; // Initial mode is to Wait
bounced := false; // Has the ball bounced?
myServe := false; // Your turn to serve? (set by Parent)
starting := false; // Your turn to start the ball? (set by Parent)
v_ball := [0,0,0]; // Ball velocity (set by Parent)
p_ball := [0,0,0]; // Ball position (set by Parent)
p_bat := [1.6*(-1)^n,0,0.2]; // Bat position (set by Parent)
v := [0,0,0]; // Bat velocity
v' := [0,0,0]; // Bat accerleration 
// The y position and velocity in z axis player can set to start the ball
yS := 0.5*(-1)^n;
zp := 4;
pH := [0,0,0]; // Heightest point of my start ball
angle_bat := [0,0,0.001]; // Normal vector of the bat's plane
angle_bat' := [0,0,0];
a_desired := [0.9471*(-1)^(n+1),0,0.4];
v_desired := [1.6*(1)^n,0,1.2];
// local timer
t := 0;
t' := 1;
// These coefficients are needed for prediction of ball movement
// Coefficient of restitution
k_z := [1.0, 1.0, -0.99];
// Coeffiecent of air resistance
k_a := -1/6;
// Ball acceleration (predicted)
a1_predicted := [0.0, 0.0, -9.8];
a2_predicted := [0.0, 0.0, -9.8];
// First prediction poit: time, position, speed
// When ball hits the table
t1_predicted := 0;
p1_predicted := [0, 0, 0];
v1_predicted := [0, 0, 0]; 
// Second prediction point: time, position, speed
// The maximum point of the second parabola
t2_predicted := 0;
p2_predicted := [0, 0, 0];
v2_predicted := [0, 0, 0];
doneOnce := false;
// Time for accelerating
ta := 0;
// Time for decelerating
td := 0;
// Unit vector of direction
u := [1,0,0];
// Distance between goal point and batp
d_ballBat := 0;
// Prediction pointers (for debugging)
_3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],
["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];
// Spherical coordinate system
r := norm([1.6,0.1,0.2]); 
r' := 0; r'' := 0;
alpha := acos(0.2/norm([-1.6,0.1,0.2]));
alpha' := 0; alpha'' := 0;
theta := atan(1.6*(-1)^n/0.1); 
theta' := 0; theta'' := 0;
x := 1.6*(-1)^n; x' := 0; x'' := 0;
y := 0.1;    y' := 0; y'' := 0;
z := 0.2; z' := 0; z'' := 0; 
end
if mode <> "Wait" && mode <> "Prepare" && mode <> "Startball" && mode <> "Reset"
mode := "Panic!";
end;
t' = 1; // Rate for local timer
// pH is the hightest from my start ball(easy to calculate from y and zp) 
pH := [1.5 * (-1)^n, yS, let t = abs(zp/(-9.8 + k_a*(zp)^2));
a = -9.8 + k_a*(zp)^2 in
zp*t + 0.5 * (a)*t^2 end];
switch mode
case "Wait" // Waiting for your serve, moving the bat to start point
v' = ([1.6*(-1)^n,0,0.4] - p_bat) * 7 + 2 * ([0,0,0]- v);
t := 0;
t1_predicted := 0;
t2_predicted := 0;
p2_predicted := [0,0,0];
doneOnce   := false;
angle_bat' = 2*([0,0,0] - angle_bat);
if myServe == true && starting == false
mode := "Prepare";
end;
// Calculate how to get to goal point(slightly behind and below pH)
if myServe == true && starting == true
t := 0; 
d_ballBat := norm(p_bat - pH); 
u := (pH + [0.07*(-1)^n,0,-0.13] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.13] - p_bat);
ta := let d_ballBat = norm(p_bat - pH) in sqrt(2 * (d_ballBat / 2) / maxA) end;
mode := "Startball";
end;
case "Startball" // Start the ball as I wanted
_3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
["Sphere",pH,0.02,[0,100,200],[0,0,0]]];
// Path planning, first half distance fully accelerate the other
// half fully decelerate
if(t < ta)
v' = maxA* u;
angle_bat = [0.9471*(-1)^(n+1),0,0.7]; 
else if (t>=ta && t<2*ta)
v' = -maxA * u; 
else if (norm(p_ball - p_bat)>0.25)
v' =10*([0,0,0]-v);
// Prepare to hit the ball
else if (norm(p_ball - p_bat)<0.25)
v' = [-7 * (p_ball(0)),0,7];
ta := 0; 
end;
end;
end;
end;
case "Prepare" // Prepare to hit the ball
//Do predict, and move pat towards the second predict point 
// Bouncing condition
if (p_ball(2)) < 0 && bounced == false
bounced := true;
end;
if bounced == true
p1_predicted = p_ball;
v1_predicted = v_ball;
t1_predicted = 0;
else
// Calculating first prediction point
// Linearized air resistance
a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball
// 1/a in z direction
t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2)) // -v0
- sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));
p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);
v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;
// Check if ball is going out of bounds
// We can predict this before it actually happens
// This actually can decrease power consuption in some cases.
if t > 0.2*abs(t1_predicted)
if (p1_predicted(0))*(-1)^n > 1.55 || (p1_predicted(0))*(-1)^n < 0 
|| abs((p1_predicted(1))) > 0.78
mode := "Wait";
myServe := false;
end;
end; 
end;
// Predict the goal point to prepare hit the ball(only do once per turn)
if (t1_predicted < 0.15 && t1_predicted <> 0) &&
((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&
doneOnce == false
// Calculating second prediction point
// Linearized air resistance
a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;
t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));
p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted * 
(t2_predicted^2);
v2_predicted = p1_predicted + a2_predicted * t2_predicted;
doneOnce := true;
// First move back a bit
// Save 0.05 sec for hit the ball with calculated velocity and angle
t2_predicted := t2_predicted - 0.05;
t := 0;
ta := t2_predicted/2;
u := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
end;
_3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]];
if doneOnce == false
v' = ([1.6*(-1)^n,0,0.4]-p_bat) * 7 + 2 * ([0,0,0]- v);
end;
// Path planning, first move to p2, then wait to hit the ball 
if doneOnce == true
ta := sqrt(2* (d_ballBat/2)/maxA);
angle_bat = a_desired;
if(t < ta)
v' = maxA* u;
else if (t>=ta && t<2*ta)
v' = -maxA * u;
else if (norm(p_ball - p_bat)>0.2)
v' =5*([0,0,0]-v);
// Prepare to hit the ball
else if (norm(p_ball - p_bat)<0.2)
v' = [-30*(p_ball(0)),0,20];
ta = 0;
end;
end;
end;
end;
end;
case "Reset" // Reset the intermediate variables to its initial value
p_bat := [1.6*(-1)^n,0,0.2];
r := norm([1.6,0.1,0.2]); 
r' := 0; r'' := 0;
alpha := acos(0.2/norm([-1.6,0.1,0.2]));
alpha' := 0; alpha'' := 0;
theta := atan(1.6*(-1)^n/0.1); 
theta' := 0; theta'' := 0;
x := 1.6*(-1)^n; x' := 0; x'' := 0; 
y := 0.1; y' := 0; y'' := 0;
z := 0.2; z' := 0; z'' := 0;
v := [0,0,0]; v' := [0,0,0];
mode := "Wait";
case "Panic!"
end;
x'' = (v'(0));
y'' = (v'(1));
z'' = (v'(2));

r'' = 1.02*(1/r)*(x*x''+y*y''+z*z''+x'*x'+y'*y'+z'*z')- (r')^2;
alpha''=-1.2*(y''*x-y*x'')/(x^2+y^2)+ ((y'*x-y*x')*(2.01*x*x'+2*y*y'))/((x^2+y^2)^2)*1.01;
theta '' =(x''*y-x*y''+(2.03*alpha')*(z*z'-r*r'))/(r^2-z^2)*1.02;
end 

class Wallace(n,maxA)
  private
    name      := "Wallace";
    mode      := "Wait";   // Initial mode is to Wait
    bounced   := false;    // Has the ball bounced?
    myServe   := false;    // Your turn to serve?  (set by Parent)
    starting  := false;    // Your turn to start the ball? (set by Parent)
    v_ball    := [0,0,0];      // Ball velocity (set by Parent)
    p_ball    := [0,0,0];      // Ball position (set by Parent)
    p_bat     := [1.6*(-1)^n,0,0.2];  // Bat  position (set by Parent)
    v         := [0,0,0];      // Bat velocity
    v'        := [0,0,0];      // Bat accerleration
    
    // The y position and velocity in z axis player can set to start the ball
    yS        := 0.5*(-1)^n;
    zp        := 4;
    pH        := [0,0,0];  // Heightest point of my start ball
    
    angle_bat  := [0,0,0.001];  // Normal vector of the bat's plane
    angle_bat' := [0,0,0];
    a_desired  := [0.9471*(-1)^(n+1),0,0.4];
    v_desired  := [1.6*(1)^n,0,1.2];
       
    // local timer
    t    := 0;
    t'   := 1;
 
    // These coefficients are needed for prediction of ball movement
    // Coefficient of restitution
    k_z := [1.0, 1.0, -0.99];
    // Coeffiecent of air resistance
    k_a := -1/6;
    // Ball acceleration (predicted)
    a1_predicted  := [0.0, 0.0, -9.8];
    a2_predicted  := [0.0, 0.0, -9.8];
    // First prediction poit: time, position, speed
    // When ball hits the table
    t1_predicted  := 0;
    p1_predicted  := [0, 0, 0];
    v1_predicted  := [0, 0, 0];
 
    // Second prediction point: time, position, speed
    // The maximum point of the second parabola
    t2_predicted  := 0;
    p2_predicted  := [0, 0, 0];
    v2_predicted  := [0, 0, 0];

    doneOnce   := false;
    // Time for accelerating
    ta         := 0;
    // Time for decelerating
    td         := 0;
    // Unit vector of direction
    u          := [1,0,0];
    // Distance between goal point and batp
    d_ballBat  := 0;
    // Prediction pointers (for debugging)
    _3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],
           ["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];

    // Spherical coordinate system
    r      := norm([1.6,0.1,0.2]);   
    r'     := 0;                     r''     := 0;
    alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
    alpha' := 0;                     alpha'' := 0;
    theta  := atan(1.6*(-1)^n/0.1);  
    theta' := 0;                     theta'' := 0;
    x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
    y  := 0.1;          y' := 0;     y''     := 0;
    z  := 0.2;          z' := 0;     z''     := 0;
  end
  
  if mode <> "Wait" && mode <> "Prepare" && mode <> "Startball" && mode <> "Reset"
     mode := "Panic!";
  end;
  
  t'  = 1;   // Rate for local timer
  // pH is the hightest from my start ball(easy to calculate from y and zp)   
  pH :=  [1.5 * (-1)^n, yS, let t = abs(zp/(-9.8 +  k_a*(zp)^2));
                              a = -9.8 +  k_a*(zp)^2 in 
                    zp*t + 0.5 * (a)*t^2 end];
  switch mode
    case "Wait" // Waiting for your serve, moving the bat to start point
      v'  = ([1.65*(-1)^n,0,0.4] - p_bat) * 7 + 2 * ([0,0,0]- v);
      t   := 0;
      t1_predicted  := 0;
      t2_predicted  := 0; 
      p2_predicted  := [0,0,0];
      doneOnce      := false;
      angle_bat'     = 2*([0,0,0] - angle_bat);
      if myServe == true && starting == false
        mode := "Prepare";
      end;
      // Calculate how to get to goal point(slightly behind and below pH)
      if myServe == true && starting == true 
        t  := 0;  
        d_ballBat := norm(p_bat - pH);
        u  := (pH + [0.07*(-1)^n,0,-0.13] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.13] - p_bat);
        ta := let d_ballBat = norm(p_bat - pH) in sqrt(2 * (d_ballBat / 2) / maxA) end;
        mode := "Startball";
      end;
    case "Startball" // Start the ball as I wanted
        _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
                ["Sphere",pH,0.02,[0,100,200],[0,0,0]]];
        
        // Path planning, first half distance fully accelerate the other 
        // half fully decelerate
         if(t < ta)
          v' = maxA* u;
          angle_bat = [0.9471*(-1)^(n+1),0,0.7];     
        else if (t>=ta && t<2*ta)
          v' = -maxA * u;          
        else if (norm(p_ball - p_bat)>0.25)
          v' =20*([0,0,0]-v);
        // Prepare to hit the ball
        else if (norm(p_ball - p_bat)<0.25)
          v' = [-7 * (p_ball(0)),0,7];
          ta := 0;      
        end;
        end;
        end;
      end;
    case "Prepare"    // Prepare to hit the ball 
      //Do predict, and move pat towards the second predict point
      // Bouncing condition
      if (p_ball(2)) < 0 && bounced == false
        bounced := true;
      end;
      if bounced == true
        p1_predicted  = p_ball;
        v1_predicted  = v_ball;
        t1_predicted  = 0;
      else
        // Calculating first prediction point
        // Linearized air resistance
        a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball
        // 1/a in z direction
        t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2))      // -v0
                       - sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));
        p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);
        v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;
        // Check if ball is going out of bounds
        // We can predict this before it actually happens
        // This actually can decrease power consuption in some cases.
        if t > 0.2*abs(t1_predicted)
          if (p1_predicted(0))*(-1)^n > 1.55 || (p1_predicted(0))*(-1)^n < 0   
             || abs((p1_predicted(1))) > 0.78
            mode    := "Wait";
            myServe := false;
          end;
        end;
      end;

      // Predict the goal point to prepare hit the ball(only do once per turn)
      if (t1_predicted < 0.15 && t1_predicted <> 0) && 
         ((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&
         doneOnce == false
      // Calculating second prediction point
      // Linearized air resistance
      a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;
      t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));
      p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted * (t2_predicted^2);
      v2_predicted = p1_predicted + a2_predicted * t2_predicted;
      doneOnce    := true;
      // First move back a bit
      // Save 0.05 sec for hit the ball with calculated velocity and angle
      t2_predicted := t2_predicted - 0.05;
      t  := 0;
      ta := t2_predicted/2;
      u  := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      end;
      _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
              ["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]];
      
    if doneOnce == false
      v'  = ([1.6*(-1)^n,0,0.4]-p_bat) * 7 + 2 * ([0,0,0]- v);
    end;
    // Path planning, first move to p2, then wait to hit the ball
    if doneOnce == true
      ta := sqrt(2* (d_ballBat/2)/maxA);
      angle_bat = a_desired;
      if(t < ta)
        v' = maxA* u;
      else if (t>=ta && t<2*ta)
        v' = -maxA * u;
      else if (norm(p_ball - p_bat)>0.2)
        v' =5*([0,0,0]-v);
      // Prepare to hit the ball
      else if (norm(p_ball - p_bat)<0.2)
        v' = [-30*(p_ball(0)),0,20];
        ta = 0;
      end;
      end;
      end;
      end;
    end;
    case "Reset"  // Reset the intermediate variables to its initial value
      p_bat := [1.6*(-1)^n,0,0.2];
      r      := norm([1.6,0.1,0.2]);   
      r'     := 0;                     r''     := 0;
      alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
      alpha' := 0;                     alpha'' := 0;
      theta  := atan(1.6*(-1)^n/0.1);  
      theta' := 0;                     theta'' := 0;
      x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
      y  := 0.1;          y' := 0;     y''     := 0;
      z  := 0.2;          z' := 0;     z''     := 0;
      v := [0,0,0];       v' := [0,0,0];
      mode := "Wait";
    case "Panic!"
  end;
  x'' = (v'(0));
  y'' = (v'(1));
  z'' = (v'(2));
  
  r''      = (4*(x*x+y*y+z*z)*(x*x''+x'*x'+y*y''+y'*y'+z*z''+z'*z')-4*(x*x'+y*y'+z*z')*(x*x'+y*y'+z*z'))/(4*sqrt((x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z))); // Derive correct equation
  alpha '' = (-4*z*(-x*z*x'+x*x*z'+y*(y*z'-z*y'))*(-x*z*x'+x*x*z'+y*(y*z'-z*y'))-(x*x+y*y)*(-8*z'*(x*x+y*y+z*z)*(x*x'+y*y'+z*z')+12*z*(x*x'+y*y'+z*z')*(x*x'+y*y'+z*z')-4*z*(x*x+y*y+z*z)*(x*x''+x'*x'+y*y''+y'*y'+z*z''+z'*z')+4*z''*(x*x+y*y+z*z)*(x*x+y*y+z*z)))/(4*((x*x+y*y)/(x*x+y*y+z*z)*sqrt((x*x+y*y)/(x*x+y*y+z*z)))*sqrt((x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z))); // Derive correct equation
  theta '' = (-1)^(n)*(x*(-x*y*(2*x'*x'+y*y''-2*y'*y')+x*x*(y*x''+2*x'*y')+y*y*(-2*x'*y'+y*x'')+x*x*x*(-y'')))/(sqrt(x*x)*(x*x+y*y)*(x*x+y*y)); // Derive correct equation

end

class Wallace1(n,maxA)
  private
    name      := "wallace";
    mode      := "Wait";   // Initial mode is to Wait
    bounced   := false;    // Has the ball bounced?
    myServe   := false;    // Your turn to serve?  (set by Parent)
    starting  := false;    // Your turn to start the ball? (set by Parent)
    v_ball    := [0,0,0];      // Ball velocity (set by Parent)
    p_ball    := [0,0,0];      // Ball position (set by Parent)
    p_bat     := [1.6*(-1)^n,0,0.2];  // Bat  position (set by Parent)
    v         := [0,0,0];      // Bat velocity
    v'        := [0,0,0];      // Bat accerleration
    
    // The y position and velocity in z axis player can set to start the ball
    yS        := 0.5*(-1)^n;
    zp        := 4;
    pH        := [0,0,0];  // Heightest point of my start ball
    
    angle_bat  := [0,0,0.001];  // Normal vector of the bat's plane
    angle_bat' := [0,0,0];
    a_desired  := [0.9471*(-1)^(n+1),0,0.4];
    v_desired  := [1.6*(1)^n,0,1.2];
       
    // local timer
    t    := 0;
    t'   := 1;
 
    // These coefficients are needed for prediction of ball movement
    // Coefficient of restitution
    k_z := [1.0, 1.0, -0.99];
    // Coeffiecent of air resistance
    k_a := -1/5.6;
    // Ball acceleration (predicted)
    a1_predicted  := [0.0, 0.0, -9.8];
    a2_predicted  := [0.0, 0.0, -9.8];
    // First prediction poit: time, position, speed
    // When ball hits the table
    t1_predicted  := 0;
    p1_predicted  := [0, 0, 0];
    v1_predicted  := [0, 0, 0];
 
    // Second prediction point: time, position, speed
    // The maximum point of the second parabola
    t2_predicted  := 0;
    p2_predicted  := [0, 0, 0];
    v2_predicted  := [0, 0, 0];

    doneOnce   := false;
    // Time for accelerating
    ta         := 0;
    // Time for decelerating
    td         := 0;
    // Unit vector of direction
    u          := [1,0,0];
    // Distance between goal point and batp
    d_ballBat  := 0;
    // Prediction pointers (for debugging)
    _3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],
           ["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];

    // Spherical coordinate system
    r      := norm([1.6,0.1,0.2]);   
    r'     := 0;                     r''     := 0;
    alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
    alpha' := 0;                     alpha'' := 0;
    theta  := atan(1.6*(-1)^n/0.1);  
    theta' := 0;                     theta'' := 0;
    x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
    y  := 0.1;          y' := 0;     y''     := 0;
    z  := 0.2;          z' := 0;     z''     := 0;
  end
  
  if mode <> "Wait" && mode <> "Prepare" && mode <> "Startball" && mode <> "Reset"
     mode := "Panic!";
  end;
  
  t'  = 1;   // Rate for local timer
  // pH is the hightest from my start ball(easy to calculate from y and zp)   
  pH :=  [1.5 * (-1)^n, yS, let t = abs(zp/(-9.8 +  k_a*(zp)^2));
                              a = -9.8 +  k_a*(zp)^2 in 
                    zp*t + 0.5 * (a)*t^2 end];
  switch mode
    case "Wait" // Waiting for your serve, moving the bat to start point
      v'  = ([1.6*(-1)^n,0,0.4] - p_bat) * 7 + 2 * ([0,0,0]- v);
      t   := 0;
      t1_predicted  := 0;
      t2_predicted  := 0; 
      p2_predicted  := [0,0,0];
      doneOnce      := false;
      angle_bat'     = 2*([0,0,0] - angle_bat);
      if myServe == true && starting == false
        mode := "Prepare";
      end;
      // Calculate how to get to goal point(slightly behind and below pH)
      if myServe == true && starting == true 
        t  := 0;  
        d_ballBat := norm(p_bat - pH);
        u  := (pH + [0.07*(-1)^n,0,-0.13] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.13] - p_bat);
        ta := let d_ballBat = norm(p_bat - pH) in sqrt(2 * (d_ballBat / 2) / maxA) end;
        mode := "Startball";
      end;
    case "Startball" // Start the ball as I wanted
        _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
                ["Sphere",pH,0.02,[0,100,200],[0,0,0]]];
        
        // Path planning, first half distance fully accelerate the other 
        // half fully decelerate
         if(t < ta)
          v' = maxA* u;
          angle_bat = [0.9471*(-1)^(n+1),0,0.7];     
        else if (t>=ta && t<2*ta)
          v' = -maxA * u;          
        else if (norm(p_ball - p_bat)>0.25)
          v' =10*([0,0,0]-v);
        // Prepare to hit the ball
        else if (norm(p_ball - p_bat)<0.25)
          v' = [-7 * (p_ball(0)),0,7];
          ta := 0;      
        end;
        end;
        end;
      end;
    case "Prepare"    // Prepare to hit the ball 
      //Do predict, and move pat towards the second predict point
      // Bouncing condition
      if (p_ball(2)) < 0 && bounced == false
        bounced := true;
      end;
      if bounced == true
        p1_predicted  = p_ball;
        v1_predicted  = v_ball;
        t1_predicted  = 0;
      else
        // Calculating first prediction point
        // Linearized air resistance
        a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball
        // 1/a in z direction
        t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2))      // -v0
                       - sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));
        p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);
        v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;
        // Check if ball is going out of bounds
        // We can predict this before it actually happens
        // This actually can decrease power consuption in some cases.
        if t > 0.2*abs(t1_predicted)
          if (p1_predicted(0))*(-1)^n > 1.55 || (p1_predicted(0))*(-1)^n < 0   
             || abs((p1_predicted(1))) > 0.78
            mode    := "Wait";
            myServe := false;
          end;
        end;
      end;

      // Predict the goal point to prepare hit the ball(only do once per turn)
      if (t1_predicted < 0.15 && t1_predicted <> 0) && 
         ((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&
         doneOnce == false
      // Calculating second prediction point
      // Linearized air resistance
      a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;
      t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));
      p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted * (t2_predicted^2);
      v2_predicted = p1_predicted + a2_predicted * t2_predicted;
      doneOnce    := true;
      // First move back a bit
      // Save 0.05 sec for hit the ball with calculated velocity and angle
      t2_predicted := t2_predicted - 0.05;
      t  := 0;
      ta := t2_predicted/2;
      u  := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      end;
      _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
              ["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]];
      
    if doneOnce == false
      v'  = ([1.6*(-1)^n,0,0.4]-p_bat) * 7 + 2 * ([0,0,0]- v);
    end;
    // Path planning, first move to p2, then wait to hit the ball
    if doneOnce == true
      ta := sqrt(2* (d_ballBat/2)/maxA);
      angle_bat = a_desired;
      if(t < ta)
        v' = maxA* u;
      else if (t>=ta && t<2*ta)
        v' = -maxA * u;
      else if (norm(p_ball - p_bat)>0.2)
        v' =5*([0,0,0]-v);
      // Prepare to hit the ball
      else if (norm(p_ball - p_bat)<0.2)
        v' = [-30*(p_ball(0)),0,20];
        ta = 0;
      end;
      end;
      end;
      end;
    end;
    case "Reset"  // Reset the intermediate variables to its initial value
      p_bat := [1.6*(-1)^n,0,0.2];
      r      := norm([1.6,0.1,0.2]);   
      r'     := 0;                     r''     := 0;
      alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
      alpha' := 0;                     alpha'' := 0;
      theta  := atan(1.6*(-1)^n/0.1);  
      theta' := 0;                     theta'' := 0;
      x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
      y  := 0.1;          y' := 0;     y''     := 0;
      z  := 0.2;          z' := 0;     z''     := 0;
      v := [0,0,0];       v' := [0,0,0];
      mode := "Wait";
    case "Panic!"
  end;
  x'' = (v'(0));
  y'' = (v'(1));
  z'' = (v'(2));
  
  r''      = ((-r'/r^2)*(x*x'+y*y'+z*z'))+((x'/r)*(x*x''+x'))+((y'/r)*(y*y''+y'))+((z'/r)*(z*z''+z')); // Derive correct equation
  alpha '' = (y*x''-x*y''-2*(x*x'+y*y')*theta')/(x^2+y^2); // Derive correct equation
  theta '' = ((x'/(x^2+y^2)^2)*((2*x*x'*y)-(x^2+y^2)*(x''*y)+(x^2+y^2)*(y')-(x*y')*(2*x)))+((y'/((x^2+y^2)^2))*((2*(x')*y^2)-((x^2+y^2)*(x'))+((x*y'')*(x^2+y^2))-(2*x*y*y'))); // Derive correct equation

end

class Swastik(n,maxA)
  private
    name      := "Swastik";
    mode      := "Wait";   // Initial mode is to Wait
    bounced   := false;    // Has the ball bounced?
    myServe   := false;    // Your turn to serve?  (set by Parent)
    starting  := false;    // Your turn to start the ball? (set by Parent)
    v_ball    := [0,0,0];      // Ball velocity (set by Parent)
    p_ball    := [0,0,0];      // Ball position (set by Parent)
    p_bat     := [1.6*(-1)^n,0,0.2];  // Bat  position (set by Parent)
    v         := [0,0,0];      // Bat velocity
    v'        := [0,0,0];      // Bat accerleration
    
    // The y position and velocity in z axis player can set to start the ball
    yS        := 0.5*(-1)^n;
    zp        := 4;
    pH        := [0,0,0];  // Heightest point of my start ball
    
    angle_bat  := [0,0,0.001];  // Normal vector of the bat's plane
    angle_bat' := [0,0,0];
    a_desired  := [0.9471*(-1)^(n+1),0,0.4];
    v_desired  := [1.6*(1)^n,0,1.2];
       
    // local timer
    t    := 0;
    t'   := 1;
 
    // These coefficients are needed for prediction of ball movement
    // Coefficient of restitution
    k_z := [1.0, 1.0, -0.99];
    // Coeffiecent of air resistance
    k_a := -1/6;
    // Ball acceleration (predicted)
    a1_predicted  := [0.0, 0.0, -9.8];
    a2_predicted  := [0.0, 0.0, -9.8];
    // First prediction poit: time, position, speed
    // When ball hits the table
    t1_predicted  := 0;
    p1_predicted  := [0, 0, 0];
    v1_predicted  := [0, 0, 0];
 
    // Second prediction point: time, position, speed
    // The maximum point of the second parabola
    t2_predicted  := 0;
    p2_predicted  := [0, 0, 0];
    v2_predicted  := [0, 0, 0];

    doneOnce   := false;
    // Time for accelerating
    ta         := 0;
    // Time for decelerating
    td         := 0;
    // Unit vector of direction
    u          := [1,0,0];
    // Distance between goal point and batp
    d_ballBat  := 0;
    // Prediction pointers (for debugging)
    _3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],
           ["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];

    // Spherical coordinate system
    r      := norm([1.6,0.1,0.2]);   
    r'     := 0;                     r''     := 0;
    alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
    alpha' := 0;                     alpha'' := 0;
    theta  := atan(1.6*(-1)^n/0.1);  
    theta' := 0;                     theta'' := 0;
    x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
    y  := 0.1;          y' := 0;     y''     := 0;
    z  := 0.2;          z' := 0;     z''     := 0;
  end
  
  if mode <> "Wait" && mode <> "Prepare" && mode <> "Startball" && mode <> "Reset"
     mode := "Panic!";
  end;
  
  t'  = 1;   // Rate for local timer
  // pH is the hightest from my start ball(easy to calculate from y and zp)   
  pH :=  [1.5 * (-1)^n, yS, let t = abs(zp/(-9.8 +  k_a*(zp)^2));
                              a = -9.8 +  k_a*(zp)^2 in 
                    zp*t + 0.5 * (a)*t^2 end];
  switch mode
    case "Wait" // Waiting for your serve, moving the bat to start point
      v'  = ([1.6*(-1)^n,0,0.4] - p_bat) * 7 + 2 * ([0,0,0]- v);
      t   := 0;
      t1_predicted  := 0;
      t2_predicted  := 0; 
      p2_predicted  := [0,0,0];
      doneOnce      := false;
      angle_bat'     = 2*([0,0,0] - angle_bat);
      if myServe == true && starting == false
        mode := "Prepare";
      end;
      // Calculate how to get to goal point(slightly behind and below pH)
      if myServe == true && starting == true 
        t  := 0;  
        d_ballBat := norm(p_bat - pH);
        u  := (pH + [0.07*(-1)^n,0,-0.13] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.13] - p_bat);
        ta := let d_ballBat = norm(p_bat - pH) in sqrt(2 * (d_ballBat / 2) / maxA) end;
        mode := "Startball";
      end;
    case "Startball" // Start the ball as I wanted
        _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
                ["Sphere",pH,0.02,[0,100,200],[0,0,0]]];
        
        // Path planning, first half distance fully accelerate the other 
        // half fully decelerate
         if(t < ta)
          v' = maxA* u;
          angle_bat = [0.9471*(-1)^(n+1),0,0.7];     
        else if (t>=ta && t<2*ta)
          v' = -maxA * u;          
        else if (norm(p_ball - p_bat)>0.25)
          v' =10*([0,0,0]-v);
        // Prepare to hit the ball
        else if (norm(p_ball - p_bat)<0.25)
          v' = [-7 * (p_ball(0)),0,7];
          ta := 0;      
        end;
        end;
        end;
      end;
    case "Prepare"    // Prepare to hit the ball 
      //Do predict, and move pat towards the second predict point
      // Bouncing condition
      if (p_ball(2)) < 0 && bounced == false
        bounced := true;
      end;
      if bounced == true
        p1_predicted  = p_ball;
        v1_predicted  = v_ball;
        t1_predicted  = 0;
      else
        // Calculating first prediction point
        // Linearized air resistance
        a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball
        // 1/a in z direction
        t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2))      // -v0
                       - sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));
        p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);
        v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;
        // Check if ball is going out of bounds
        // We can predict this before it actually happens
        // This actually can decrease power consuption in some cases.
        if t > 0.2*abs(t1_predicted)
          if (p1_predicted(0))*(-1)^n > 1.55 || (p1_predicted(0))*(-1)^n < 0   
             || abs((p1_predicted(1))) > 0.78
            mode    := "Wait";
            myServe := false;
          end;
        end;
      end;

      // Predict the goal point to prepare hit the ball(only do once per turn)
      if (t1_predicted < 0.15 && t1_predicted <> 0) && 
         ((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&
         doneOnce == false
      // Calculating second prediction point
      // Linearized air resistance
      a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;
      t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));
      p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted * (t2_predicted^2);
      v2_predicted = p1_predicted + a2_predicted * t2_predicted;
      doneOnce    := true;
      // First move back a bit
      // Save 0.05 sec for hit the ball with calculated velocity and angle
      t2_predicted := t2_predicted - 0.05;
      t  := 0;
      ta := t2_predicted/2;
      u  := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      end;
      _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
              ["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]];
      
    if doneOnce == false
      v'  = ([1.6*(-1)^n,0,0.4]-p_bat) * 7 + 2 * ([0,0,0]- v);
    end;
    // Path planning, first move to p2, then wait to hit the ball
    if doneOnce == true
      ta := sqrt(2* (d_ballBat/2)/maxA);
      angle_bat = a_desired;
      if(t < ta)
        v' = maxA* u;
      else if (t>=ta && t<2*ta)
        v' = -maxA * u;
      else if (norm(p_ball - p_bat)>0.2)
        v' =5*([0,0,0]-v);
      // Prepare to hit the ball
      else if (norm(p_ball - p_bat)<0.2)
        v' = [-30*(p_ball(0)),0,20];
        ta = 0;
      end;
      end;
      end;
      end;
    end;
    case "Reset"  // Reset the intermediate variables to its initial value
      p_bat := [1.6*(-1)^n,0,0.2];
      r      := norm([1.6,0.1,0.2]);   
      r'     := 0;                     r''     := 0;
      alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
      alpha' := 0;                     alpha'' := 0;
      theta  := atan(1.6*(-1)^n/0.1);  
      theta' := 0;                     theta'' := 0;
      x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
      y  := 0.1;          y' := 0;     y''     := 0;
      z  := 0.2;          z' := 0;     z''     := 0;
      v := [0,0,0];       v' := [0,0,0];
      mode := "Wait";
    case "Panic!"
  end;
  x'' = (v'(0));
  y'' = (v'(1));
  z'' = (v'(2));
  
  r''      = (x*x''+(x')^2+y*y''+(y')^2+z*z''+(z')^2-(r')^2)/r; 
 alpha'' = (r*sqrt(r^2-z^2)*(z*r''-z''*r)-(z*r'-z'*r)*((2*r*(r^2-z^2)^(-1/2)*(r*r'-z*z')+sqrt(r^2-z^2)*r')))/((r^2)*(r^2-z^2)); 
theta'' = (y*x''-x*y''-2*(x*x'+y*y')*alpha')/(x^2+y^2); 
end

class Sparta(n,maxA)
 private
   name      := "sparta";
   mode      := "Wait";   // Initial mode is to Wait
   bounced   := false;    // Has the ball bounced?
   myServe   := false;    // Your turn to serve?  (set by Parent)
   starting  := false;    // Your turn to start the ball? (set by Parent)
  v_ball    := [0.3535/(n+4),0.3535,0.5];      // Ball velocity (set by Parent)
   p_ball    := [ 0,0,0 ];      // Ball position (set by Parent)
   p_bat     := [1.6*(-1)^n,0.20,0.4];  // Bat  position (set by Parent)
   v         := [0.3535/(n+4),0.3535,0.5];      // Bat velocity
   v'        := [ 0 , 0 , 0 ];      // Bat accerleration
   // The y position and velocity in z axis player can set to start the ball
   yS        :=((-1)^n)*0.772;
   zp        := 4.5;
   pH        := [0,0,0];  // Heightest point of my start ball
   angle_bat  := [0,sin(pi/6),cos(7*pi/12)*(-1)^(n-1)];  // Normal vector of the bat's plane
  angle_bat' := [0,0,0];
   a_desired  := [0.9471*(-1)^(n+1),0,0.4];
   v_desired  := [1.6*(1)^n,0,1.2];
   // local timer
   t    := 0;
  t'   := 1;
   // These coefficients are needed for prediction of ball movement
   // Coefficient of restitution
   k_z := [1.0, 1.0, -0.99];
   // Coeffiecent of air resistance
   k_a := -1/6;

   // Ball acceleration (predicted)
   a1_predicted  := [0.0, 0.0, -9.8];
   a2_predicted  := [0.0, 0.0, -9.8];
   // First prediction poit: time, position, speed
   // When ball hits the table
   t1_predicted  := 0;
   p1_predicted  := [0, 0, 0];
   v1_predicted  := [0, 0, 0];
   // Second prediction point: time, position, speed
   // The maximum point of the second parabola
   t2_predicted  := 0;
   p2_predicted  := [0, 0, 0];
   v2_predicted  := [0, 0, 0];
   doneOnce   := false;
   // Time for accelerating
  ta         := 0;
   // Time for decelerating
   td         := 0;
   // Unit vector of direction
   u          := [1,0,0];
   // Distance between goal point and batp
   d_ballBat  := 0;
   // Prediction pointers (for debugging)
   _3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],

          ["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];

   // Spherical coordinate system

   r      := norm([1.6,0.1,0.2]);   

   r'     := 0;                     r''     := 0;

   alpha  := acos(0.2/norm([-1.6,0.1,0.2]));

   alpha' := 0;                     alpha'' := 0;

   theta  := atan(1.6*(-1)^n/0.1);  

   theta' := 0;                     theta'' := 0;

   x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;

   y  := 0.1;          y' := 0;     y''     := 0;

   z  := 0.2;          z' := 0;     z''     := 0;

 end

 

 if mode <> "Wait" && mode <> "Prepare" && mode <> "Startball" && mode <> "Reset"

    mode := "Panic!";

 end;

 

 t'  = 1;   // Rate for local timer

 // pH is the hightest from my start ball(easy to calculate from y and zp)   

 pH :=  [1.5 * (-1)^n, yS, let t = abs(zp/(-9.8 +  k_a*(zp)^2));

                             a = -9.8 +  k_a*(zp)^2 in

                   zp*t + 0.5 * (a)*t^2 end];

 switch mode

   case "Wait" // Waiting for your serve, moving the bat to start point

     v'  = ([1.6*(-1)^n,0,0.4] - p_bat) * 7 + 2 * ([0,0,0]- v);

     t   := 0;

     t1_predicted  := 0;

     t2_predicted  := 0;

     p2_predicted  := [0,0,0];

     doneOnce      := false;

     angle_bat'     = 2*([0,0,0] - angle_bat);

     if myServe == true && starting == false

       mode := "Prepare";

     end;

     // Calculate how to get to goal point(slightly behind and below pH)

     if myServe == true && starting == true

       t  := 0;  

       d_ballBat := norm(p_bat - pH);

       u  := (pH + [0.07*(-1)^n,0,-0.13] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.13] - p_bat);

       ta := let d_ballBat = norm(p_bat - pH) in sqrt(2 * (d_ballBat / 2) / maxA) end;

       mode := "Startball";

     end;

   case "Startball" // Start the ball as I wanted

       _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],

               ["Sphere",pH,0.02,[0,100,200],[0,0,0]]];

       

       // Path planning, first half distance fully accelerate the other

       // half fully decelerate

        if(t < ta)

         v' = maxA* u;

         angle_bat = [0.9471*(-1)^(n+1),0,0.7];     

       else if (t>=ta && t<2*ta)

         v' = -maxA * u;          

       else if (norm(p_ball - p_bat)>0.25)

         v' =10*([0,0,0]-v);

       // Prepare to hit the ball

       else if (norm(p_ball - p_bat)<0.25)

         v' = [-7 * (p_ball(0)),0,7];

         ta := 0;      

       end;

       end;

       end;

     end;

   case "Prepare"    // Prepare to hit the ball

     //Do predict, and move pat towards the second predict point

     // Bouncing condition

     if (p_ball(2)) < 0 && bounced == false

       bounced := true;

     end;

     if bounced == true

       p1_predicted  = p_ball;

       v1_predicted  = v_ball;

       t1_predicted  = 0;

     else

       // Calculating first prediction point

       // Linearized air resistance

       a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball

       // 1/a in z direction

       t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2))      // -v0

                      - sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));

       p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);

       v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;

       // Check if ball is going out of bounds

       // We can predict this before it actually happens

       // This actually can decrease power consuption in some cases.

       if t > 0.2*abs(t1_predicted)

         if (p1_predicted(0))*(-1)^n > 1.55 || (p1_predicted(0))*(-1)^n < 0   

            || abs((p1_predicted(1))) > 0.78

           mode    := "Wait";

           myServe := false;

         end;

       end;

     end;

     // Predict the goal point to prepare hit the ball(only do once per turn)

     if (t1_predicted < 0.15 && t1_predicted <> 0) &&

        ((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&

        doneOnce == false

     // Calculating second prediction point

     // Linearized air resistance

     a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;

     t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));

     p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted * (t2_predicted^2);

     v2_predicted = p1_predicted + a2_predicted * t2_predicted;

     doneOnce    := true;

     // First move back a bit

     // Save 0.05 sec for hit the ball with calculated velocity and angle

     t2_predicted := t2_predicted - 0.05;

     t  := 0;

     ta := t2_predicted/2;

     u  := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);

     d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);

     end;

     _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],

             ["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]];

     

   if doneOnce == false

     v'  = ([1.6*(-1)^n,0,0.4]-p_bat) * 7 + 2 * ([0,0,0]- v);

   end;

   // Path planning, first move to p2, then wait to hit the ball

   if doneOnce == true

     ta := sqrt(2* (d_ballBat/2)/maxA);

     angle_bat = a_desired;

     if(t < ta)

       v' = maxA* u;

     else if (t>=ta && t<2*ta)

       v' = -maxA * u;

     else if (norm(p_ball - p_bat)>0.2)

       v' =5*([0,0,0]-v);

     // Prepare to hit the ball

     else if (norm(p_ball - p_bat)<0.2)

       v' = [-30*(p_ball(0)),0,20];

       ta = 0;

     end;

     end;

     end;

     end;

   end;

   case "Reset"  // Reset the intermediate variables to its initial value

     p_bat := [1.6*(-1)^n,0,0.2];

     r      := norm([1.6,0.1,0.2]);   

     r'     := 0;                     r''     := 0;

     alpha  := acos(0.2/norm([-1.6,0.1,0.2]));

     alpha' := 0;                     alpha'' := 0;

     theta  := atan(1.6*(-1)^n/0.1);  

     theta' := 0;                     theta'' := 0;

     x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;

     y  := 0.1;          y' := 0;     y''     := 0;

     z  := 0.2;          z' := 0;     z''     := 0;

     v := [0,0,0];       v' := [0,0,0];

     mode := "Wait";

   case "Panic!"

 end;

 x'' = (v'(0));

 y'' = (v'(1));

 z'' = (v'(2));

 r''      = ((x'^2+y'^2+z'^2+x*x''+y*y''+z*z'')-(r'^2))/r;      // Derive correct equation
theta'' =((x''*y-x*y'')-2*theta'*(x*x'+y*y'))/(x^2+y^2);
alpha''= ((z*r''-z''*r)/((r)*(x^2+y^2)^(1/2)))-((r'*alpha')/r)-(((x*x'+y*y')*alpha'))/(x^2+y^2);
end


//PingWee 0.4
/*
A sraight port of our previous player.
We removed the moving average filter since it did not seem to affect the our player noticeably.
Derivatives of r, alpha and theta were computed on paper with help and verification by Wolfram alpha.
Minor tweaks in the computation of force needed for return.

Regrettably it seems we wont have time to implement two features that we have wanted to include from the start
-catching the ball by the table edge if the peak of the trajectory is too far away
-reverse-engineering the prediction formulas to be able to predict the force needed to make optimal shots
*/
class PeeWee(n,maxA)
  private /*------------------------- Privates -------------------------*/
    name      := "PeeWee";
    mode      := "Wait";
    bounced   := false;

    //Inputs (set by parent)
    myServe   := false; starting  := false; // Your turn to hit or start
    v_ball    := [0,0,0]; p_ball := [0,0,0]; // Ball velocity/position
    p_bat     := [1.6*(-1)^n,0,0.2];  // Bat  position
    
    v         := [0,0,0];      // Bat velocity
    v'        := [0,0,0];      // Bat acceleration
    
    // Starting ball parameters
    yS := 0.5*(-1)^n; zp := 4.0; pH := [0,0,0];  //y position, z-speed, Declare: Heightest point; of my start ball
    
    angle_bat  := [0,0,0.001];  // Normal vector of the bat's plane
    angle_bat' := [0,0,0];
    a_desired  := [0.9471*(-1)^(n+1),0,0.4];
    v_desired  := [1.6*(1)^n,0,1.2];
    
    // local timer
    t := 0; t' := 1;
    
    // These coefficients are needed for prediction of ball movement
    k_z := [1.0, 1.0, -0.99]; // Coefficient of restitution
    k_a := -1/6; // Coeffiecent of air resistance
    a1_predicted  := [0.0, 0.0, -9.8]; a2_predicted  := [0.0, 0.0, -9.8]; // Ball acceleration (predicted)
      
    // Prediction points: time, position, speed
    // When ball hits the table
    t1_predicted  := 0; p1_predicted  := [0, 0, 0]; v1_predicted  := [0, 0, 0];
    // The maximum point of the second parabola
    t2_predicted  := 0; p2_predicted  := [0, 0, 0]; v2_predicted  := [0, 0, 0];
    // The point where the ball passes our board edge
    t3_predicted  := 0; p3_predicted  := [0, 0, 0]; v3_predicted  := [0, 0, 0];
    
    doneOnce   := false;
    Iterate := 0;
    firstStartBall := true;
    
    // Declare: Time for accelerating, decelerating
    ta := 0;  td := 0;
    u := [1,0,0]; // Unit vector of direction
    d_ballBat  := 0; // Declare: Distance between goal point and batp
    
    // Prediction pointers (for debugging)
    _3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]
           ,["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]
           ,["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]
           ];
    
    // Spherical coordinate system
    r      := norm([1.6,0.1,0.2]);   
    r'     := 0;                     r''     := 0;
    alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
    alpha' := 0;                     alpha'' := 0;
    theta  := atan(1.6*(-1)^n/0.1);  
    theta' := 0;                     theta'' := 0;
    x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
    y  := 0.1;          y' := 0;     y''     := 0;
    z  := 0.2;          z' := 0;     z''     := 0;
    
    
  end /*------------------------- Code -------------------------*/
  
  if mode <> "Wait" && mode <> "Prepare" && mode <> "Startball" && mode <> "Reset"
     mode := "Panic!";
     Iterate := 0;
  end;
  
  // pH is the hightest point of the startball before hitting it, used by Startball mode
  pH :=  [1.5 * (-1)^n, yS, let t = abs(zp/(-9.8 +  k_a*(zp)^2));    a = -9.8 +  k_a*(zp)^2 in 
                    zp*t + 0.5 * (a)*t^2 end];
  
  //This comment was written to commemorate the loss of the AVG function. Rest in peace.
  
  switch mode
    case "Wait" /*------------------------- Wait -------------------------*/
      Iterate = Iterate +1;
      
      t := 0; //reset variables
      t1_predicted := 0; t2_predicted := 0; t3_predicted := 0;
      p1_predicted := [0,0,0]; p2_predicted := [0,0,0]; p3_predicted := [0,0,0];
      doneOnce      := false;
      angle_bat'     := 2*(a_desired - angle_bat);
      
      if myServe == true && starting == false
        mode := "Prepare";
        Iterate := 0;
      
      else if myServe == true && starting == true
        // Calculate how to get to goal point(slightly behind and below pH)
        t := 0;
        d_ballBat := norm(p_bat - pH);
        u := (pH + [0.07*(-1)^n,0,-0.1] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.13] - p_bat); //Direction we want to move
        ta := let d_ballBat = norm(p_bat - pH) in sqrt(2* (d_ballBat / 2) / maxA) end;
        mode := "Startball";
        Iterate := 0;
      
      else //Do while waiting
        v'  := ([1.5*(-1)^n, 0.5*p_ball(1), 0.3] - p_bat) * 8 + 2 * ([0,0,0]- v); //Follow the ball in y, dampen speed
        //v'  := 5 * ([0,0,0]- v); //Follow the ball in y, dampen speed
        //Idea:
        //Predict the y-position where the ball reaches the other end of the table and move there?
        
      end;
      end;
      
    case "Startball" /*------------------------- Startball -------------------------*/
      Iterate = Iterate +1;
      
      _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]]
             ,["Sphere",pH,0.02,[0,100,200],[0,0,0]]
             ];
      
      if(myServe == false || starting == false) //If this then we really shouldn't be here
        mode := "Wait";
        Iterate := 0;
      end;
      
      // Path planning, first half distance fully accelerate the other 
      // half fully decelerate
      if(t < ta) //Move to starting point?
        v' = maxA* u;

        //angle_bat = [0.9471*(-1)^(n+1),0,0.7]; //Default
        
        a_desired = [0.9471*(-1)^(n+1), -(p_ball(1)*0.65), 0.4];
        angle_bat' = (a_desired - angle_bat)/ta; 
      else if (t>=ta && t<2*ta) //Stop at starting point?
        v' = -maxA * u;
        angle_bat = a_desired; 
      else if (norm(p_ball - p_bat)>0.25) //Does nothing? Does not trigger?
        //v' =10*([0,0,0]-v); //Default
        v' =5*([0,0,0]-v);
      else if (norm(p_ball - p_bat)<0.25)
        if(firstStartBall == true) //To adjust the first-of-the-game startball
          v' = [-6.5 * (p_ball(0)), -p_ball(1)*0, (4-p_ball(2))*3.8];
        else
          //v' = [-7 * (p_ball(0)),0,7]; //Default
          v' = [-14.5 * (p_ball(0)), -p_ball(1)*0, (4-p_ball(2))*5.5];
        end;
        ta := 0;
      end;end;end;end;
      
      
    case "Prepare" /*------------------------- Prepare -------------------------*/
      Iterate = Iterate +1;
      firstStartBall := false; //To adjust the first-of-the-game startball
      
      // Predict -> Intercept -> Hit
      //If it's not my serve then I really should not be here
      if myServe == false
        mode := "Wait";
        Iterate := 0;
      end;
      
      //Do predict, and move pat towards the second predict point
      // Bouncing condition
      if (p_ball(2)) < 0 && bounced == false
        bounced := true;
      end;
      if bounced == true
        p1_predicted  = p_ball;
        v1_predicted  = v_ball;
        t1_predicted  = 0;
      else
        // Calculating first prediction point
        // Linearized air resistance
        //                      G?    Air   Vector Abs   Ball speed
        a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball
        // 1/a in z direction
        t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2))      // -v0
                       - sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));
        p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);
        v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;
        // Check if ball is going out of bounds
        // We can predict this before it actually happens
        // This actually can decrease power consuption in some cases.
        if t > 0.2*abs(t1_predicted)
          if (p1_predicted(0))*(-1)^n > 1.55 || (p1_predicted(0))*(-1)^n < 0   
             || abs((p1_predicted(1))) > 0.78
            mode    := "Wait";
            Iterate := 0;
            myServe := false;
          end;
        end;
      end;
      
      
      // Predict the goal point to prepare hit the ball(only do once per turn)
      if (t1_predicted < 0.15 && t1_predicted <> 0) && 
         ((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&
         doneOnce == false
      // Calculating second prediction point
      // Linearized air resistance
      a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;
      t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));
      p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted * (t2_predicted^2);
      v2_predicted = p1_predicted + a2_predicted * t2_predicted;
      
      //New plan: Instead of hitting at the peak of the trajectory after bounce...
      //If p2_predicted is outside table, instead intercept the ball by the table edge
      //  Do this by computing an intermediate prediction between p1 and p2 and
      //Else play as normal (i.e. catch it at the peak point somewhere over the table)
      
      //For now
      //Check if the ball will be too difficult to catch at the peak, if so: skip
      if p2_predicted(0)*(-1)^n > 2 || abs(p2_predicted(1)) > 1 || (p2_predicted(2)) > 2
        mode    := "Wait";
        Iterate := 0;
        myServe := false;
      end;
      
      //Implement solution later
      
      //If p1_predicted is close to our table edge but on the table then move to the table edge and hit the ball just after the bounce
      
      
      
      
      doneOnce := true;
      // First move back a bit
      // Save 0.05 sec for hit the ball with calculated velocity and angle
      t2_predicted := t2_predicted - 0.05;
      t  := 0;
      ta := t2_predicted/2;
      u := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      end;
      _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]]
             ,["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]
             ];
      
    if doneOnce == false //Before having computed where to meet the ball
      //v'  = ([1.6*(-1)^n,0,0.4]-p_bat) * 7 + 2 * ([0,0,0]- v); //Default
      v'  := ([1.5*(-1)^n, 0.5*p_ball(1), 0.3] - p_bat) * 7 + 3 * ([0,0,0]- v);
    end;
    // Path planning, first move to p2, then wait to hit the ball
    if doneOnce == true //Once we have a plan
      ta := sqrt(2* (d_ballBat/2)/maxA);
      
      a_desired = [0.9471*(-1)^(n+1), -(p_ball(1)*0.55), 0.4];
      angle_bat' = (a_desired - angle_bat)/ta; //PW3
      angle_bat = a_desired;
      
      if(t < ta)
        v' = maxA* u;
      else if (t>=ta && t<2*ta)
        v' = -maxA * u;
      else if (norm(p_ball - p_bat)>0.2)//0.25
        v' =5*([0,0,0]-v);
      // Prepare to hit the ball
      else if (norm(p_ball - p_bat)<0.2)//0.25
        //v' = [-30*(p_ball(0)),0,20]; //Default
        v' = [ -23 * p_ball(0)/abs(p_ball(0)) * norm([p_ball(0), p_ball(1), 0]), -p_ball(1)*0, (1/p_ball(2)^2)*3];
        ta = 0;
      end;
      end;
      end;
      end;
    end;
    case "Reset"  // Reset the intermediate variables to its initial value
      p_bat := [1.6*(-1)^n,0,0.2];
      r      := norm([1.6,0.1,0.2]);   
      r'     := 0;                     r''     := 0;
      alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
      alpha' := 0;                     alpha'' := 0;
      theta  := atan(1.6*(-1)^n/0.1);  
      theta' := 0;                     theta'' := 0;
      x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
      y  := 0.1;          y' := 0;     y''     := 0;
      z  := 0.2;          z' := 0;     z''     := 0;
      v := [0,0,0];       v' := [0,0,0];
      mode := "Wait";
      Iterate := 0;
    case "Panic!"
  end;
  x'' = (v'(0));
  y'' = (v'(1));
  z'' = (v'(2));
  
  r''      = (1/r) * (  x*x''+y*y''+z*z'' + x'^2 + y'^2 + z'^2  -r'^2  );
  //theta '' = (((x^2)+(y^2))*(y*x''-x*y'')* -2*(y*x'-x*y')*(x*x'+y*y'))/(x^2+y^2)^2 ;
  theta '' = -( (x^2 + y^2)*( (x'*y'+x*y'')-(y'*x'+x''*y) ) - 2*(y'*x-y*x')*(x*x'+y*y') ) / ( (x^2+y^2)^2 );
  alpha '' = ( -r*(z^3)*r'' + (r^2)*z*( -2*r'^2 + z*z'' - z'^2 ) + (z^3)*r'^2 + (r^3) * ( z*r'' + 2*r'*z' ) + (r^4)*(-z'') )
           / ( (r^3) * ( r^2 - z^2 ) * sqrt( 1- (z^2)/(r^2) ) );
end


/**
 * A ping pong player, with number n.
 * Position and velocity of ball(p_ball,v_ball) are always provided by parent class.
 * maxA is the maximum accerlaration the actuator can handle.
 * */

/**
 * A ping pong player, with number n.
 * Position and velocity of ball(p_ball,v_ball) are always provided by parent class.
 * maxA is the maximum acceleration the actuator can handle.
 * */

class LPHP(n,maxA)
  private
    name      := "LPHP";
    varX      := 0;
    varZ      := 0;
    mode      := "Wait";   // Initial mode is to Wait
    bounced   := false;    // Has the ball bounced?
    myServe   := false;    // Your turn to serve?  (set by Parent)
    starting  := false;    // Your turn to start the ball? (set by Parent)
    v_ball    := [0,0,0];      // Ball velocity (set by Parent)
    p_ball    := [0,0,0];      // Ball position (set by Parent)
    p_bat     := [1.6*(-1)^n,0,0.2];  // Bat  position (set by Parent)
    v         := [0,0,0];      // Bat velocity
    v'        := [0,0,0];      // Bat accerleration
    
    // The y position and velocity in z axis player can set to start the ball
    yS        := 0.2*(-1)^n;
    zp        := 3;
    pH        := [0,0,0];  // Heightest point of my start ball
    
    angle_bat  := [0,0,0.001];  // Normal vector of the bat's plane
    angle_bat' := [0,0,0];
    a_desired  := [0.9471*(-1)^(n+1),0,0.4];
    v_desired  := [1.6*(1)^n,0,1.2];
       
    // local timer
    t    := 0;
    t'   := 1;
 
    // These coefficients are needed for prediction of ball movement
    // Coefficient of restitution
    k_z := [1.0, 1.0, -0.99];
    // Coeffiecent of air resistance
    k_a := -1/6;
    // Ball acceleration (predicted)
    a1_predicted  := [0.0, 0.0, -9.8];
    a2_predicted  := [0.0, 0.0, -9.8];
    // First prediction poit: time, position, speed
    // When ball hits the table
    t1_predicted  := 0;
    p1_predicted  := [0, 0, 0];
    v1_predicted  := [0, 0, 0];
 
    // Second prediction point: time, position, speed
    // The maximum point of the second parabola
    t2_predicted  := 0;
    p2_predicted  := [0, 0, 0];
    v2_predicted  := [0, 0, 0];

    doneOnce   := false;
    // Time for accelerating
    ta         := 0;
    // Time for decelerating
    td         := 0;
    // Unit vector of direction
    u          := [1,0,0];
    // Distance between goal point and batp
    d_ballBat  := 0;
    // Prediction pointers (for debugging)
    _3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],
           ["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];

    // Spherical coordinate system
    r      := norm([1.6,0.1,0.2]);   
    r'     := 0;                     r''     := 0;
    alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
    alpha' := 0;                     alpha'' := 0;
    theta  := atan(1.6*(-1)^n/0.1);  
    theta' := 0;                     theta'' := 0;
    x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
    y  := 0.1;          y' := 0;     y''     := 0;
    z  := 0.2;          z' := 0;     z''     := 0;
  end
  
  if mode <> "Wait" && mode <> "Prepare" && mode <> "Startball" && mode <> "Reset"
     mode := "Panic!";
  end;
  
  t'  = 1;   // Rate for local timer
  // pH is the hightest from my start ball(easy to calculate from y and zp)   
  pH :=  [1.5 * (-1)^n, yS, let t = abs(zp/(-9.8 +  k_a*(zp)^2));
                              a = -9.8 +  k_a*(zp)^2 in 
                    zp*t + 0.5 * (a)*t^2 end];
  switch mode
    case "Wait" // Waiting for your serve, moving the bat to start point
      v'  = ([1.6*(-1)^n,0,0.4] - p_bat) * 20 + 10 * ([0,0,0]- v);
      t   := 0;
      t1_predicted  := 0;
      t2_predicted  := 0; 
      p2_predicted  := [0,0,0];
      doneOnce      := false;
      angle_bat'     = 2*([0,0,0] - angle_bat);
      if myServe == true && starting == false
        mode := "Prepare";
      end;
      // Calculate how to get to goal point(slightly behind and below pH)
      if myServe == true && starting == true 
        t  := 0;  
        d_ballBat := norm(p_bat - pH);
        u  := (pH + [0.07*(-1)^n,0,-0.13] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.13] - p_bat);
        ta := let d_ballBat = norm(p_bat - pH) in sqrt(2 * (d_ballBat / 2) / maxA) end;
        mode := "Startball";
      end;
    case "Startball" // Start the ball as I wanted
        _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
                ["Sphere",pH,0.02,[0,100,200],[0,0,0]]];
        
        // Path planning, first half distance fully accelerate the other 
        // half fully decelerate
        a_desired = [0.9471*(-1)^(n+1),(-1)^(n+1)*0.3,0.4];

         if(t < ta)
          v' = maxA* u;
          angle_bat' = (a_desired - angle_bat)/ta;
         // angle_bat = [0.9471*(-1)^(n+1),0,0.7];     
        else if (t>=ta && t<2*ta)
          v' = -maxA * u;          
          angle_bat = a_desired;
        else if (norm(p_ball - p_bat)>0.3)
          v' =5*([0,0,0]-v);
        // Prepare to hit the ball
        else if (norm(p_ball - p_bat)<0.3)
          v' = [(-1)^(n+1)*5-v(0),0,8-v(2)];
          ta := 0;      
        end;
        end;
        end;
      end;
    case "Prepare"    // Prepare to hit the ball 
      //Do predict, and move pat towards the second predict point
      // Bouncing condition
      if (p_ball(2)) < 0 && bounced == false
        bounced := true;
      end;
      if bounced == true
        p1_predicted  = p_ball;
        v1_predicted  = v_ball;
        t1_predicted  = 0;
        a_desired = [0.9471*(-1)^(n+1),(-1)^(n+1)*0.25*atan(p1_predicted(1)/p1_predicted(0)) + (-1)^(n+1)*atan(v1_predicted(1)/v1_predicted(0)),0.4];
      else
        // Calculating first prediction point
        // Linearized air resistance
        a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball
        // 1/a in z direction
        t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2))      // -v0
                       - sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));
        p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);
        v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;
        // Check if ball is going out of bounds
        // We can predict this before it actually happens
        // This actually can decrease power consuption in some cases.
        if t > 0.2*abs(t1_predicted)
          if (p1_predicted(0))*(-1)^n > 1.55 || (p1_predicted(0))*(-1)^n < 0.1   
             || abs((p1_predicted(1))) > 0.78
            mode    := "Wait";
            myServe := false;
          end;
        end;
      end;

      // Predict the goal point to prepare hit the ball(only do once per turn)
      if (t1_predicted < 0.15 && t1_predicted <> 0) && 
         ((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&
         doneOnce == false
      // Calculating second prediction point
      // Linearized air resistance
      a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;
      t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));
      p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted * (t2_predicted^2);
      v2_predicted = p1_predicted + a2_predicted * t2_predicted;
      doneOnce    := true;
      // First move back a bit
      // Save 0.05 sec for hit the ball with calculated velocity and angle
      t2_predicted := t2_predicted - 0.05;
      t  := 0;
      ta := t2_predicted/2;
      u  := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      end;
      _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
              ["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]];
      
    if doneOnce == false
      v'  = ([1.6*(-1)^n,0,0.4]-p_bat) * 7 + 2 * ([0,0,0]- v);
    end;
    // Path planning, first move to p2, then wait to hit the ball
    if doneOnce == true
      ta := sqrt(2* (d_ballBat/2)/maxA);
      angle_bat' = (a_desired - angle_bat)/ta;
      //angle_bat = a_desired;
      if(t < ta)
        
        v' = maxA* u;
       

      else if (t>=ta && t<2*ta)
        v' = -maxA * u;
      else if (norm(p_ball - p_bat)>0.2)
        v' =10*([0,0,0]-v);
      // Prepare to hit the ball
      else if (norm(p_ball - p_bat)<0.2)
        varX = 50*(abs(p_ball(0)))-norm(v_ball)*15;
        varZ = varX;     
        v' = [(-1)^(n+1)*varX-v(0),0,varZ-v(2)];
        ta = 0;
      end;
      end;
      end;
      end;
    end;
    case "Reset"  // Reset the intermediate variables to its initial value
      p_bat := [1.6*(-1)^n,0,0.2];
      r      := norm([1.6,0.1,0.2]);   
      r'     := 0;                     r''     := 0;
      alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
      alpha' := 0;                     alpha'' := 0;
      theta  := atan(1.6*(-1)^n/0.1);  
      theta' := 0;                     theta'' := 0;
      x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
      y  := 0.1;          y' := 0;     y''     := 0;
      z  := 0.2;          z' := 0;     z''     := 0;
      v := [0,0,0];       v' := [0,0,0];
      mode := "Wait";
    case "Panic!"
  end;
  x'' = (v'(0));
  y'' = (v'(1));
  z'' = (v'(2));
 
  r'' = (4*(x*x+y*y+z*z)*(x*x''+x'*x'+y*y''+y'*y'+z*z''+z'*z')-4*(x*x'+y*y'+z*z')*(x*x'+y*y'+z*z'))/(4*sqrt((x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)));
  alpha '' = (-4*z*(-x*z*x'+x*x*z'+y*(y*z'-z*y'))*(-x*z*x'+x*x*z'+y*(y*z'-z*y'))-(x*x+y*y)*(-8*z'*(x*x+y*y+z*z)*(x*x'+y*y'+z*z')+12*z*(x*x'+y*y'+z*z')*(x*x'+y*y'+z*z')-4*z*(x*x+y*y+z*z)*(x*x''+x'*x'+y*y''+y'*y'+z*z''+z'*z')+4*z''*(x*x+y*y+z*z)*(x*x+y*y+z*z)))/(4*((x*x+y*y)/(x*x+y*y+z*z)*sqrt((x*x+y*y)/(x*x+y*y+z*z)))*sqrt((x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)*(x*x+y*y+z*z)));
  theta'' = (-1)^(n)*(x*(-x*y*(2*x'*x'+y*y''-2*y'*y')+x*x*(y*x''+2*x'*y')+y*y*(-2*x'*y'+y*x'')+x*x*x*(-y'')))/(sqrt(x*x)*(x*x+y*y)*(x*x+y*y));
 
end

class Gatz(n,maxA)
  private
    name      := "Gatz";
    mode      := "Wait";   // Initial mode is to Wait
    bounced   := false;    // Has the ball bounced?
    myServe   := false;    // Your turn to serve?  (set by Parent)
    starting  := false;    // Your turn to start the ball? (set by Parent)
    v_ball    := [0,0,0];      // Ball velocity (set by Parent)
    p_ball    := [0,0,0];      // Ball position (set by Parent)
    p_bat     := [1.6*(-1)^n,0,0.2];  // Bat  position (set by Parent)
    v         := [0,0,0];      // Bat velocity
    v'        := [0,0,0];      // Bat acceleration
    
    // The y position and velocity in z axis player can set to start the ball
    yS        := 0.5*(-1)^n;
    zp        := 4;
    pH        := [2,0,0];  // Heightest point of my start ball
    
    angle_bat  := [0,0,0.001];  // Normal vector of the bat's plane
    angle_bat' := [0,0,0];
    a_desired  := [0.9471*(-1)^(n+1),0,0.4];
    v_desired  := [1.6*(1)^n,0,1.2];
       
    // local timer
    t    := 0;
    t'   := 1;
 
    // These coefficients are needed for prediction of ball movement
    // Coefficient of restitution
    k_z := [1.0, 1.0, -0.99];
    // Coeffiecent of air resistance
    k_a := -1/6;
    // Ball acceleration (predicted)
    a1_predicted  := [0.0, 0.0, -9.8];
    a2_predicted  := [0.0, 0.0, -9.8];
    // First prediction poit: time, position, speed
    // When ball hits the table
    t1_predicted  := 0;
    p1_predicted  := [0, 0, 0];
    v1_predicted  := [0, 0, 0];
 
    // Second prediction point: time, position, speed
    // The maximum point of the second parabola
    t2_predicted  := 0;
    p2_predicted  := [0, 0, 0];
    v2_predicted  := [0, 0, 0];

    doneOnce   := false;
    // Time for accelerating
    ta         := 0;
    // Time for decelerating
    td         := 0;
    // Unit vector of direction
    u          := [1,0,0];
    // Distance between goal point and batp
    d_ballBat  := 0;
    // Prediction pointers (for debugging)
    _3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],
           ["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];

    // Spherical coordinate system
    r      := norm([1.6,0.1,0.2]);   
    r'     := 0;                     r''     := 0;
    alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
    alpha' := 0;                     alpha'' := 0;
    theta  := atan(1.6*(-1)^n/0.1);  
    theta' := 0;                     theta'' := 0;
    x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
    y  := 0.1;          y' := 0;     y''     := 0;
    z  := 0.2;          z' := 0;     z''     := 0;
  end
  
  if mode <> "Wait" && mode <> "Prepare" && mode <> "Startball" && mode <> "Reset"
     mode := "Panic!";
  end;
  
  t'  = 1;   // Rate for local timer
  // pH is the hightest from my start ball(easy to calculate from y and zp)   
  pH :=  [1.5*(-1)^n, yS, let t = abs(zp/(-9.8 +  k_a*(zp)^2));
                              a = -9.8 +  k_a*(zp)^2 in 
                    zp*t + 0.5 * (a)*t^2 end];
  switch mode
    case "Wait" // Waiting for your serve, moving the bat to start point
      v'  = ([1.6*(-1)^n,0,0.4] - p_bat) * 7 + 2 * ([0,0,0]- v);
      t   := 0;
      t1_predicted  := 0;
      t2_predicted  := 0; 
      p2_predicted  := [0,0,0];
      doneOnce      := false;
      angle_bat'     = 2*([0,0,0] - angle_bat);
      if myServe == true && starting == false
        mode := "Prepare";
      end;
      // Calculate how to get to goal point(slightly behind and below pH)
      if myServe == true && starting == true 
        t  := 0;  
        d_ballBat := norm(p_bat - pH);
        u  := (pH + [0.07*(-1)^n,0,-0.13] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.13] - p_bat);
        ta := let d_ballBat = norm(p_bat - pH) in sqrt(2 * (d_ballBat / 2) / maxA) end;
        mode := "Startball";
      end;
    case "Startball" // Start the ball as I wanted
        _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
                ["Sphere",pH,0.02,[0,100,200],[0,0,0]]];
        
        // Path planning, first half distance fully accelerate the other 
        // half fully decelerate
         if(t < ta)
          v' = maxA* u;
          angle_bat = [0.9471*(-1)^(n+1),0,0.7];     
        else if (t>=ta && t<2*ta)
          v' = -maxA * u;          
        else if (norm(p_ball - p_bat)>0.25)
          v' =10*([0,0,0]-v);
        // Prepare to hit the ball
        else if (norm(p_ball - p_bat)<0.25)
          v' = [-7 * (p_ball(0)),0,7];
          ta := 0;      
        end;
        end;
        end;
      end;
    case "Prepare"    // Prepare to hit the ball 
      //Do predict, and move pat towards the second predict point
      // Bouncing condition
      if (p_ball(2)) < 0 && bounced == false
        bounced := true;
      end;
      if bounced == true
        p1_predicted  = p_ball;
        v1_predicted  = v_ball;
        t1_predicted  = 0;
      else
        // Calculating first prediction point
        // Linearized air resistance
        a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball
        // 1/a in z direction
        t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2))      // -v0
                       - sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));
        p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);
        v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;
        // Check if ball is going out of bounds
        // We can predict this before it actually happens
        // This actually can decrease power consuption in some cases.
        if t > 0.2*abs(t1_predicted)
          if (p1_predicted(0))*(-1)^n > 1.55 || (p1_predicted(0))*(-1)^n < 0   
             || abs((p1_predicted(1))) > 0.78
            mode    := "Wait";
            myServe := false;
          end;
        end;
      end;

      // Predict the goal point to prepare hit the ball(only do once per turn)
      if (t1_predicted < 0.15 && t1_predicted <> 0) && 
         ((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&
         doneOnce == false
      // Calculating second prediction point
      // Linearized air resistance
      a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;
      t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));
      p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted * (t2_predicted^2);
      v2_predicted = p1_predicted + a2_predicted * t2_predicted;
      doneOnce    := true;
      // First move back a bit
      // Save 0.05 sec for hit the ball with calculated velocity and angle
      t2_predicted := t2_predicted - 0.05;
      t  := 0;
      ta := t2_predicted/2;
      u  := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      end;
      _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
              ["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]];
      
    if doneOnce == false
      v'  = ([1.6*(-1)^n,0,0.4]-p_bat) * 7 + 2 * ([0,0,0]- v);
    end;
    // Path planning, first move to p2, then wait to hit the ball
    if doneOnce == true
      ta := sqrt(2* (d_ballBat/2)/maxA);
      angle_bat = a_desired;
      if(t < ta)
        v' = maxA* u;
      else if (t>=ta && t<2*ta)
        v' = -maxA * u;
      else if (norm(p_ball - p_bat)>0.2)
        v' =5*([0,0,0]-v);
      // Prepare to hit the ball
      else if (norm(p_ball - p_bat)<0.2)
        v' = [-30*(p_ball(0)),0,20];
        ta = 0;
      end;
      end;
      end;
      end;
    end;
    case "Reset"  // Reset the intermediate variables to its initial value
      p_bat := [1.6*(-1)^n,0,0.2];
      r      := norm([1.6,0.1,0.2]);   
      r'     := 0;                     r''     := 0;
      alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
      alpha' := 0;                     alpha'' := 0;
      theta  := atan(1.6*(-1)^n/0.1);  
      theta' := 0;                     theta'' := 0;
      x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
      y  := 0.1;          y' := 0;     y''     := 0;
      z  := 0.2;          z' := 0;     z''     := 0;
      v := [0,0,0];       v' := [0,0,0];
      mode := "Wait";
    case "Panic!"
  end;
  x'' = (v'(0));
  y'' = (v'(1));
  z'' = (v'(2));
//**************************************************************************************************  
  //r'' = (1 - z^2/(x^2 + y^2 + z^2))^(1/2)*(x^2 + y^2 + z^2)^(1/2); // Derive correct equation
  /*alpha = theta = ((x''*y-x*y'')-2*theta'*(x*x'+y*y'))/((x^2)+(y^2)); hits the ball*/
  /*r''=1/r*(x*x''+y*y''+z*z''+(x'^2)+(y'^2)+(z'^2)-(r'^2));//mesa/e3w
  //r''=0;
  //alpha''=(x''*y-x*y''+(2*alpha')*(z*z'-r*r'))/((r^2)-(z^2));//panw/katw
  alpha''=-1.7*(((r*r'-z*z')*(z-z*r'))/(r*((r^2)-(z^2)))+((z''-z*r''-z'*r')/(r^2)))/(sqrt((r^2)-(z^2)));
  //theta '' = z; // Derive correct equation
  //theta''=(((r*r'-z*z')*(z-z*r'))/(r*((r^2)-(z^2)))+((z''-z*r''-z'*r')/(r^2)))/(sqrt((r^2)-(z^2)));//ar/de3
  theta''=((x''*y-x*y'')-2*theta'*(x*x'+y*y'))/((x^2)+(y^2));
  //theta''=0;*/
   r''    = (1/r)*(x*x''+y*y''+z*z''+x'*x'+y'*y'+z'*z')- (r')^2;
   alpha''=-1.2*(y''*x-y*x'')/(x^2+y^2)+ ((y'*x-y*x')*(2*x*x'+2*y*y'))/((x^2+y^2)^2);
   theta '' =(x''*y-x*y''+(2*alpha')*(z*z'-r*r'))/(r^2-z^2);// 
//**************************************************************************************************
end

// Weiren She , Amir Askari

/*
Group: Falafel
Group Members: Jafar Qutteineh & Karthi Keyan

Report:
The player for  P6 is based on the player of P4 (not P5) as the effect of quantization and discretization is not considered in this mode.
The following changes were made:  
-Added equations for r'',theta'' & alpha''. The equations were derived by hand and plugged back into acumen.
-New if statement at the beginning of the close to handle the new Reset Mode.

No other changes were made.

*/

class Falafel(n,maxA)
  private
    name      := "Falafel";
    mode      := "Wait";   // Initial mode is to Wait
    bounced   := false;    // Has the ball bounced?
    myServe   := false;    // Your turn to serve?  (set by Parent)
    starting  := false;    // Your turn to start the ball? (set by Parent)
    v_ball    := [0,0,0];      // Ball velocity (set by Parent)
    p_ball    := [0,0,0];      // Ball position (set by Parent)
    p_bat     := [1.6*(-1)^n,0,0.2];  // Bat  position (set by Parent)
    v         := [0,0,0];      // Bat velocity
    v'        := [0,0,0];      // Bat accerleration
    
    // The y position and velocity in z axis player can set to start the ball
    yS         := 0.5*(-1)^n;
    zp        := 4;
    pH        :=[0,0,0];
    
    angle_bat  := [0,0,0.001];  // Normal vector of the bat's plane
    angle_bat' := [0,0,0];

    dv_bounced:=0; //reflect bounce value for debugging
    dv_myServe:=0; //reflect myServe value for debugging
    dv_starting:=0;//reflect starting value for debugging

    dv_pred_a:=[0,0,0]; //predicted accelaration of the ball

    
    //Our local time : t
    t:=0;
    t':=1;
    
    dv_t_bounce:=0;  //time to bounce
    dv_p_bounce:=[0,0,0]; // position at bounce
    dv_v_bounce:=[0,0,0]; // speed at bounce
    dv_p_sweetSpot:=[0,0,0]; //sweet spot to hit the ball

    dv_mode:="wait_to_approach";

    d_bat_ball:=[0,0,0]; //distance between ball and batt
    u:=[0,0,0];  //unit vector pointing from the bat toward the ball.
    _3D:=[];

        // Spherical coordinate system
    r      := norm([1.6,0.1,0.2]);   
    r'     := 0;                     r''     := 0;
    alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
    alpha' := 0;                     alpha'' := 0;
    theta  := atan(1.6*(-1)^n/0.1);  
    theta' := 0;                     theta'' := 0;
    x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
    y  := 0.1;          y' := 0;     y''     := 0;
    z  := 0.2;          z' := 0;     z''     := 0;
  end

if mode=="Reset"
      p_bat := [1.6*(-1)^n,0,0.2];
      r      := norm([1.6,0.1,0.2]);   
      r'     := 0;                     r''     := 0;
      alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
      alpha' := 0;                     alpha'' := 0;
      theta  := atan(1.6*(-1)^n/0.1);  
      theta' := 0;                     theta'' := 0;
      x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
      y  := 0.1;          y' := 0;     y''     := 0;
      z  := 0.2;          z' := 0;     z''     := 0;
      v := [0,0,0];       v' := [0,0,0];
      mode := "Wait";
 end;
  
dv_pred_a := [0,0,-9.8];
if (starting==true)
  dv_mode:="serve_my_ball";
end;

if dv_mode=="wait_to_approach" && p_ball(2)<=0 && bounced==false
  bounced=true;
end;

//do we've a net case?
if dv_mode=="wait_to_approach" && norm(v_ball)<0.01 && abs(p_ball(0))<0.1 && bounced==false
  //yes we've...wait for reset
   dv_mode="wait_next_round";
end;

switch dv_mode
 case "serve_my_ball"
     angle_bat=[1.35*(-1)^(n+1),-p_ball(1)/2,0.57];
     u=d_bat_ball/norm(d_bat_ball); 
     if  v_ball(2)>0 && p_ball(2)<0.6
       v'=80*([1.55*(-1)^(n),0.4*(-1)^(n),0.55]-p_bat)-10*v; //ball is still asending...go to position
      
   //hit
   else
     
     //angle_bat=[0.9471*(-1)^(n+1),0,0.9];
     
     starting=false;
   end;
   if  p_ball(2)>0.62  //the ball has is about to desend
       if norm (p_bat-p_ball)<0.25 
         v'=[10*(-1)^(n+1),0,3];
         dv_mode="about_to_serve";
       end;
     end;
 case "about_to_serve"
  if ((n==1 && v_ball(0)>0)||(n==2 && v_ball(0)<0)) && v_ball(2)>0 //the ball was hit
    v'=[20*(-1)^(n),0,-28]; //slow down to the previous point
    dv_mode="wait_other_player";
  end
 case "wait_to_approach"
 
    dv_t_bounce:=( -v_ball(2)-sqrt(v_ball(2)^2-2*p_ball(2)*dv_pred_a(2)))/dv_pred_a(2);
    dv_p_bounce:=p_ball + v_ball*dv_t_bounce+0.5*dv_pred_a*dv_t_bounce^2;
    dv_v_bounce:=(v_ball + dv_pred_a*dv_t_bounce).*[1,1,-0.99];

  //check whether the ball will bounce on my side or not
  if (n==1 && dv_p_bounce(0)<-1.65 && bounced==false &&p_ball(0)<-0.5)||(n==2 && dv_p_bounce(0)>1.65 && bounced==false &&p_ball(0)>0.5)||(abs(dv_p_bounce(1))>0.75 &&bounced==false)
    dv_mode="wait_next_round";
    //bounced=false;
  end;
  if (p_ball(0)>0 && n==1)||(p_ball(0)<0 && n==2) //stop updating past the net
     dv_p_sweetSpot=(dv_p_bounce+dv_v_bounce*0.2+0.5*dv_pred_a*(0.2)^2)+[0.2*(-1)^n,0,-0.1]; //check which time maybe better
  end;

  d_bat_ball:=p_ball-p_bat;
  if norm(d_bat_ball)>0.2 //&& v_ball(0)<0
   //approach
     if (n==1 && p_ball(0)<0.1 && v_ball(0)<0)||(n==2 && p_ball(0)>-0.1 && v_ball(0)>0) //the ball is moving toward us and passed the 0.1 cm after the net
       v'=10*(-1*v-5*(p_bat-dv_p_sweetSpot));
       //angle_bat=[1.1*(-1)^(n+1),(-1)^(n)*p_ball(1)/2,0.57];
       angle_bat=[1.1*(-1)^(n+1),-p_ball(1)/2,0.57];
     end;
   //hit
   else
     if (u==[0,0,0] && ((v_ball(0)<0 &&n==1)||((v_ball(0)>0 &&n==2))))   //capture u only once every turn
       u=d_bat_ball/norm(d_bat_ball); 
       //angle_bat=[0.9471*(-1)^(n+1),0,0.7];
       
     end;
     //angle_bat=[1.1*(-1),(-1)*p_ball(1)/2,0.57];
     //angle_bat=[1.1,p_ball(1)/2,0.57];
     angle_bat=[1.1*(-1)^(n+1),-p_ball(1)/2,0.57];
     v'=10*abs(p_ball(0))*u.*[1,1,1]+[-0.5*p_ball(0),0,0];
     dv_mode="about_to_hit";
   end;
case "about_to_hit"
//check if we've already hit the ball
  if u==[0,0,0]
    //To do
  end;
  if (n==1 && v_ball(0)>0) ||(n==2 && v_ball(0) <0) //ball was hit and now moving away
   u=[0,0,0];
   bounced=false;
   dv_mode="wait_other_player";
  end;
case "wait_other_player"
 if ((n==1 && v_ball(0)<0 && p_ball(0)<0.2)||(n==2 && v_ball(0)>0 && p_ball(0)>-0.2)) && p_ball(2)>0.4 && abs(p_ball(1))<0.75
   //the oother player has his the ball and now it's approaching us. We also make sure we've no net condition
   dv_mode="wait_to_approach";      
 end;
 //dampen our position
 if dv_p_sweetSpot==[0,0,0] || (norm(p_bat-dv_p_sweetSpot)>norm(p_bat-[1.55*(-1)^(n),0.4*(-1)^(n),0.55]))//stil not calculated (this will happen for the right hand player at first serve) or it's too far return to origin
   dv_p_sweetSpot=[1.55*(-1)^(n),0.4*(-1)^(n),0.55]; //assume starting position
 end;
 v'=10*(dv_p_sweetSpot-p_bat)-3*v;
case "wait_next_round"
//dampn our position...no prefared position to return to
v'=-3*v;
//had the ball been reset?
if abs(p_ball(0))==1.50
  dv_mode="wait_to_approach";
  
end;
end;

  if (bounced==true)
    dv_bounced:=1;
  else
    dv_bounced:=0;
  end;

  if (dv_myServe==true)
    dv_myServe:=1;
  else
    dv_myServe:=0;
  end;

  if (starting==true)
    dv_starting:=1;
  else
    dv_starting:=0;
  end;

    x'' = (v'(0));
  y'' = (v'(1));
  z'' = (v'(2));
  //r=sqrt(x^2+y^2+z^2);
  
  r''      = ((x'^2+y'^2+z'^2+x*x''+y*y''+z*z'')/r)-((x*x'+y*y'+z*z')^2/r^3); // Derive correct equation
 
  alpha '' = -1*((z''/r)-((2*x*x'+2*y*y'+2*z*z')*z'/r^3)-
             (z*(x'^2+y'^2+z'^2+x*x''+y*y''+z*z'')/r^3) +
             (3*z*(x*x'+y*y'+z*z')^2/r^5))/((x^2+y^2)/r^2)^0.5 -
             (z*(x^2*z'-z*x*x'+y^2*z'-z*y*y')^2/((x^2+y^2)^1.5*r^4));

  theta '' = -1*(x*(y*(2*x'^2-2*y'^2)+y^2*y'')-x^2*(y*x''+2*y'*x')+
              x^3*y''-y^3*x''+2*y^2*x'*y')/((x^2+y^2)^2);

/*

  _3D:=[["Text",[-0.2,0.78,1.45],0.15,red,[pi/2,0,0],mode],
        ["Text",[-0.5,0.78,1.3],0.1,red,[pi/2,0,0],"p_ball = "],
        ["Text",[-0.1,0.78,1.3],0.1,red,[pi/2,0,0],p_ball(0)*100],
        ["Text",[0.2,0.78,1.3],0.1,red,[pi/2,0,0],p_ball(1)*100],
        ["Text",[0.5,0.78,1.3],0.1,red,[pi/2,0,0],p_ball(2)*100],
        ["Text",[-0.5,0.78,1.2],0.1,red,[pi/2,0,0],"v_ball = "],
        ["Text",[-0.1,0.78,1.2],0.1,red,[pi/2,0,0],v_ball(0)*100],
        ["Text",[0.2,0.78,1.2],0.1,red,[pi/2,0,0],v_ball(1)*100],
        ["Text",[0.5,0.78,1.2],0.1,red,[pi/2,0,0],v_ball(2)*100],
        ["Text",[-0.5,0.78,1.1],0.1,red,[pi/2,0,0],"p_bat = "],
        ["Text",[-0.1,0.78,1.1],0.1,red,[pi/2,0,0],p_bat(0)*100],
        ["Text",[0.2,0.78,1.1],0.1,red,[pi/2,0,0],p_bat(1)*100],
        ["Text",[0.5,0.78,1.1],0.1,red,[pi/2,0,0],p_bat(2)*100],
        ["Text",[-0.5,0.78,1.0],0.1,red,[pi/2,0,0],"v_bat = "],
        ["Text",[-0.1,0.78,1.0],0.1,red,[pi/2,0,0],v(0)*100],
        ["Text",[0.2,0.78,1.0],0.1,red,[pi/2,0,0],v(1)*100],
        ["Text",[0.5,0.78,1.0],0.1,red,[pi/2,0,0],v(2)*100],
*/
/* 
        ["Text",[-0.5,0.78,0.9],0.1,red,[pi/2,0,0],"a_bat = "],
        ["Text",[-0.1,0.78,0.9],0.1,red,[pi/2,0,0],v'(0)*100],
        ["Text",[0.2,0.78,0.9],0.1,red,[pi/2,0,0],v'(1)*100],
        ["Text",[0.5,0.78,0.9],0.1,red,[pi/2,0,0],v'(2)*100],
        ["Text",[-0.5,0.78,0.8],0.1,red,[pi/2,0,0],"angle = "],
        ["Text",[-0.1,0.78,0.8],0.1,red,[pi/2,0,0],angle_bat(0)*100],
        ["Text",[0.2,0.78,0.8],0.1,red,[pi/2,0,0],angle_bat(1)*100],
        ["Text",[0.5,0.78,0.8],0.1,red,[pi/2,0,0],angle_bat(2)*100],
        ["Text",[-0.5,0.78,0.7],0.1,red,[pi/2,0,0],"angle' = "],
        ["Text",[-0.1,0.78,0.7],0.1,red,[pi/2,0,0],angle_bat'(0)*100],
        ["Text",[0.2,0.78,0.7],0.1,red,[pi/2,0,0],angle_bat'(1)*100],
        ["Text",[0.5,0.78,0.7],0.1,red,[pi/2,0,0],angle_bat'(2)*100],
        ["Text",[-0.5,0.78,0.6],0.1,red,[pi/2,0,0],"bounced = "],
        ["Text",[0.1,0.78,0.6],0.1,red,[pi/2,0,0],dv_bounced],
        ["Text",[-0.5,0.78,0.5],0.1,red,[pi/2,0,0],"myServe = "],
        ["Text",[0.1,0.78,0.5],0.1,red,[pi/2,0,0],dv_myServe],
        ["Text",[-0.5,0.78,0.4],0.1,red,[pi/2,0,0],"starting = "],
        ["Text",[0.1,0.78,0.4],0.1,red,[pi/2,0,0],dv_starting],
        ["Text",[-0.5,0.78,0.3],0.1,red,[pi/2,0,0],"pred_a = "],
        ["Text",[-0.1,0.78,0.3],0.1,red,[pi/2,0,0],dv_pred_a(0)*100],
        ["Text",[0.2,0.78,0.3],0.1,red,[pi/2,0,0],dv_pred_a(1)*100],
        ["Text",[0.5,0.78,0.3],0.1,red,[pi/2,0,0],dv_pred_a(2)*100],
        ["Text",[-0.5,0.78,1.7],0.1,red,[pi/2,0,0],"time = "],
        ["Text",[0.1,0.78,1.7],0.1,red,[pi/2,0,0],t*100],
        ["Text",[-0.5,0.78,1.8],0.1,red,[pi/2,0,0],"t_bounce = "],
        ["Text",[0.1,0.78,1.8],0.1,red,[pi/2,0,0],(dv_t_bounce+t)*100],
        ["Sphere",dv_p_bounce,0.05,green,[0,0,0]],
        ["Text",[-0.5,0.78,1.6],0.1,red,[pi/2,0,0],"p_bnc= "],
        ["Text",[-0.1,0.78,1.6],0.1,red,[pi/2,0,0],dv_p_bounce(0)*100],
        ["Text",[0.2,0.78,1.6],0.1,red,[pi/2,0,0],dv_p_bounce(1)*100],
        ["Text",[0.5,0.78,1.6],0.1,red,[pi/2,0,0],dv_p_bounce(2)*100],
*/
/* 
        ["Text",[-2,0.78,0.3],0.1,red,[pi/2,0,0],"v_bnc = "],
        ["Text",[-1.6,0.78,0.3],0.1,red,[pi/2,0,0],dv_v_bounce(0)*100],
        ["Text",[-1.3,0.78,0.3],0.1,red,[pi/2,0,0],dv_v_bounce(1)*100],
        ["Text",[-1.0,0.78,0.3],0.1,red,[pi/2,0,0],dv_v_bounce(2)*100],
        ["Text",[-2,0.78,0.4],0.1,red,[pi/2,0,0],"p_spot = "],
        ["Text",[-1.6,0.78,0.4],0.1,red,[pi/2,0,0],dv_p_sweetSpot(0)*100],
        ["Text",[-1.3,0.78,0.4],0.1,red,[pi/2,0,0],dv_p_sweetSpot(1)*100],
        ["Text",[-1.0,0.78,0.4],0.1,red,[pi/2,0,0],dv_p_sweetSpot(2)*100],
        ["Text",[-2,0.78,0.5],0.1,red,[pi/2,0,0],"mode = "],
        ["Text",[-1.6,0.78,0.5],0.1,red,[pi/2,0,0],dv_mode],
        ["Text",[-2,0.78,0.6],0.1,red,[pi/2,0,0],"u = "],
        ["Text",[-1.6,0.78,0.6],0.1,red,[pi/2,0,0],u(0)*100],
        ["Text",[-1.3,0.78,0.6],0.1,red,[pi/2,0,0],u(1)*100],
        ["Text",[-1.0,0.78,0.6],0.1,red,[pi/2,0,0],u(2)*100],
        ["Text",[-2,0.78,0.7],0.1,red,[pi/2,0,0],"pH = "],
        ["Text",[-1.6,0.78,0.7],0.1,red,[pi/2,0,0],pH(0)*100],
        ["Text",[-1.3,0.78,0.7],0.1,red,[pi/2,0,0],pH(1)*100],
        ["Text",[-1.0,0.78,0.7],0.1,red,[pi/2,0,0],pH(2)*100],
        ["Text",[-2,0.78,0.8],0.1,red,[pi/2,0,0],"p_bnc = "],
        ["Text",[-1.6,0.78,0.8],0.1,red,[pi/2,0,0],dv_p_bounce(0)*100],
        ["Text",[-1.3,0.78,0.8],0.1,red,[pi/2,0,0],dv_p_bounce(1)*100],
        ["Text",[-1.0,0.78,0.8],0.1,red,[pi/2,0,0],dv_p_bounce(2)*100]];      
*/
  
end

class ErrorTeam(n,maxA)
  private
    name      := "error";
    mode      := "Wait";   // Initial mode is to Wait
    bounced   := false;    // Has the ball bounced?
    myServe   := false;    // Your turn to serve?  (set by Parent)
    starting  := false;    // Your turn to start the ball? (set by Parent)
    v_ball    := [0,0,0];      // Ball velocity (set by Parent)
    p_ball    := [0,0,0];      // Ball position (set by Parent)
    p_bat     := [1.6*(-1)^n,0,0.6];  // Bat  position (set by Parent)
    v         := [0,0,0];      // Bat velocity
    v'        := [0,0,0];      // Bat accerleration
    
    // The y position and velocity in z axis player can set to start the ball
    yS        := 0.5*(-1)^n;
    zp        := 4;
    pH        := [0,0,4];  // Heightest point of my start ball
    
    angle_bat  := [0,0,0.001];  // Normal vector of the bat's plane
    angle_bat' := [0,0,0];
    a_desired  := [0.9471*(-1)^(n+1),0,0.2];
    v_desired  := [1.6*(1)^n,0,1.2];
       
    // local timer
    t    := 0;
    t'   := 1;
 
    // These coefficients are needed for prediction of ball movement
    // Coefficient of restitution
    k_z := [1.0, 1.0, -0.99];
    // Coeffiecent of air resistance
    k_a := -1/6;
    // Ball acceleration (predicted)
    a1_predicted  := [0.0, 0.0, -9.8];
    a2_predicted  := [0.0, 0.0, -9.8];
    // First prediction poit: time, position, speed
    // When ball hits the table
    t1_predicted  := 0;
    p1_predicted  := [0, 0, 0];
    v1_predicted  := [0, 0, 0];
 
    // Second prediction point: time, position, speed
    // The maximum point of the second parabola
    t2_predicted  := 0;
    p2_predicted  := [0, 0, 0];
    v2_predicted  := [0, 0, 0];


    doneOnce   := false;
    // Time for accelerating
    ta         := 0;
    // Time for decelerating
    td         := 0;
    // Unit vector of direction
    u          := [1,0,0];
    // Distance between goal point and batp
    d_ballBat  := 0;
    // Prediction pointers (for debugging)
    _3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],
           ["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];


    // Spherical coordinate system
    r      := norm([1.6,0.1,0.2]);   
    r'     := 0;                     r''     := 0;
    alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
    alpha' := 0;                     alpha'' := 0;
    theta  := atan(1.6*(-1)^n/0.1);  
    theta' := 0;                     theta'' := 0;
    x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
    y  := 0.1;          y' := 0;     y''     := 0;
    z  := 0.2;          z' := 0;     z''     := 0;
  end
  
  if mode <> "Wait" && mode <> "Prepare" && mode <> "Startball" && mode <> "Reset"
     mode := "Panic!";
  end;
  
  t'  = 1;   // Rate for local timer
  // pH is the hightest from my start ball(easy to calculate from y and zp)   
  pH :=  [1.5 * (-1)^n, yS, let t = abs(zp/(-9.8 +  k_a*(zp)^2));
                              a = -9.8 +  k_a*(zp)^2 in 
                    zp*t + 0.5 * (a)*t^2 end];
  switch mode
    case "Wait" // Waiting for your serve, moving the bat to start point
      v'  = ([1.6*(-1)^n,0,0.1] - p_bat) * 2.5 + 5 * ([0,0,0]- v);
      t   := 0;
      t1_predicted  := 0;
      t2_predicted  := 0; 
      p2_predicted  := [0,0,0];
      doneOnce      := false;
      angle_bat'     = 2*([0,0,0] - angle_bat);
      if myServe == true && starting == false
        mode := "Prepare";
      end;
      // Calculate how to get to goal point(slightly behind and below pH)
      if myServe == true && starting == true 
        t  := 0;  
        d_ballBat := norm(p_bat - pH);
        u  := (pH + [0.07*(-1)^n,0,-0.1] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.1] - p_bat);
        ta := let d_ballBat = norm(p_bat - pH) in sqrt(2 * (d_ballBat / 2) / maxA) end;
        mode := "Startball";
      end;
    case "Startball" // Start the ball as I wanted
        _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
                ["Sphere",pH,0.02,[0,100,200],[0,0,0]]];
        
        // Path planning, first half distance fully accelerate the other 
        // half fully decelerate
         if(t < ta)
          v' = 1.1*maxA* u;
          angle_bat = [0.9471*(-1)^(n+1),0,0.7];     
        else if (t>=ta && t<2*ta)
          v' = -maxA * u;          
        else if (norm(p_ball - p_bat)>0.25)
          v' =5*([0,0,0]-v);
        // Prepare to hit the ball
        else if (norm(p_ball - p_bat)<0.25)
          v' = [-5.5 * (p_ball(0)),0,5];
          ta := 0;      
        end;
        end;
        end;
      end;
    case "Prepare"    // Prepare to hit the ball 
      //Do predict, and move pat towards the second predict point
      // Bouncing condition
      if (p_ball(2)) < 0 && bounced == false
        bounced := true;
      end;
      if bounced == true
        p1_predicted  = p_ball;
        v1_predicted  = v_ball;
        t1_predicted  = 0;
      else
        // Calculating first prediction point
        // Linearized air resistance
        a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball
        // 1/a in z direction
        t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2))      // -v0
                       - sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));
        p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);
        v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;
        // Check if ball is going out of bounds
        // We can predict this before it actually happens
        // This actually can decrease power consuption in some cases.
        if t > 0.2*abs(t1_predicted)
          if (p1_predicted(0))*(-1)^n > 1.55 || (p1_predicted(0))*(-1)^n < 0   
             || abs((p1_predicted(1))) > 0.78
            mode    := "Wait";
            myServe := false;
          end;
        end;
      end;


      // Predict the goal point to prepare hit the ball(only do once per turn)
      if (t1_predicted < 0.15 && t1_predicted <> 0) && 
         ((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&
         doneOnce == false
      // Calculating second prediction point
      // Linearized air resistance
      a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;
      t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));
      p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted * (t2_predicted^2);
      v2_predicted = p1_predicted + a2_predicted * t2_predicted;
      doneOnce    := true;
      // First move back a bit
      // Save 0.05 sec for hit the ball with calculated velocity and angle
      t2_predicted := t2_predicted - 0.05;
      t  := 0;
      ta := t2_predicted/2;
      u  := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      end;
      _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
              ["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]];
      
    if doneOnce == false
      v'  = ([1.6*(-1)^n,0,0.2]-p_bat)*5  + 5 * ([0,0,0]- v);
    end;
    // Path planning, first move to p2, then wait to hit the ball
    if doneOnce == true
      ta := sqrt(2* (d_ballBat/2)/maxA);
      angle_bat = a_desired;
      if(t < ta)
        v' = maxA* u;
      else if (t>=ta && t<2*ta)
        v' = -maxA * u;
      else if (norm(p_ball - p_bat)>0.2)
        v' =2*([0,0,0]-v);
      // Prepare to hit the ball
      else if (norm(p_ball - p_bat)<0.2)
        v' = [-30*(p_ball(0)),0,20];
        ta = 0;
      end;
      end;
      end;
      end;
    end;
    case "Reset"  // Reset the intermediate variables to its initial value
      p_bat := [1.6*(-1)^n,0,0.2];
      r      := norm([1.6,0.1,0.2]);   
      r'     := 0;                     r''     := 0;
      alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
      alpha' := 0;                     alpha'' := 0;
      theta  := atan(1.6*(-1)^n/0.1);  
      theta' := 0;                     theta'' := 0;
      x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
      y  := 0.1;          y' := 0;     y''     := 0;
      z  := 0.2;          z' := 0;     z''     := 0;
      v := [0,0,0];       v' := [0,0,0];
      mode := "Wait";
    case "Panic!"
  end;
  x'' = (v'(0));
  y'' = (v'(1));
  z'' = (v'(2));
  r''    = (1/r)*(x*x''+y*y''+z*z''+x'*x'+y'*y'+z'*z')*0.2- (r')^2;
  alpha''=(x''*y-x*y''+(2*alpha')*(z*z'-r*r'))/(r^2-z^2);
  theta '' =-(y''*x-y*x'')/(x^2+y^2)+ ((y'*x-y*x')*(2*x*x'+2*y*y'))/((x^2+y^2)^2);

end


class Endless(n,maxA)
  private
    name      := "Endless";
    mode      := "Wait";   // Initial mode is to Wait
    bounced   := false;    // Has the ball bounced?
    myServe   := false;    // Your turn to serve?  (set by Parent)
    starting  := false;    // Your turn to start the ball? (set by Parent)
    v_ball    := [0,0,0];      // Ball velocity (set by Parent)
    p_ball    := [0,0,0];      // Ball position (set by Parent)
    p_bat     := [1.6*(-1)^n,0,0.2];  // Bat  position (set by Parent)
    v         := [0,0,0];      // Bat velocity
    v'        := [0,0,0];      // Bat accerleration
    
    // The y position and velocity in z axis player can set to start the ball
    yS        := 0.5*(-1)^n;
    zp        := 4;
    pH        := [0,0,0];  // Heightest point of my start ball
    
    angle_bat  := [0,0,0.001];  // Normal vector of the bat's plane
    angle_bat' := [0,0,0];
    a_desired  := [0.9471*(-1)^(n+1),0,0.4];
    v_desired  := [1.6*(1)^n,0,1.2];
       
    // local timer
    t    := 0;
    t'   := 1;
 
    // These coefficients are needed for prediction of ball movement
    // Coefficient of restitution
    k_z := [1.0, 1.0, -0.99];
    // Coeffiecent of air resistance
    k_a := -1/6;
    // Ball acceleration (predicted)
    a1_predicted  := [0.0, 0.0, -9.8];
    a2_predicted  := [0.0, 0.0, -9.8];
    // First prediction poit: time, position, speed
    // When ball hits the table
    t1_predicted  := 0;
    p1_predicted  := [0, 0, 0];
    v1_predicted  := [0, 0, 0];
 
    // Second prediction point: time, position, speed
    // The maximum point of the second parabola
    t2_predicted  := 0;
    p2_predicted  := [0, 0, 0];
    v2_predicted  := [0, 0, 0];

    doneOnce   := false;
    // Time for accelerating
    ta         := 0;
    // Time for decelerating
    td         := 0;
    // Unit vector of direction
    u          := [1,0,0];
    // Distance between goal point and batp
    d_ballBat  := 0;
    // Prediction pointers (for debugging)
    _3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],
           ["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];

    // Spherical coordinate system
    r      := norm([1.6,0.1,0.2]);   
    r'     := 0;                     r''     := 0;
    alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
    alpha' := 0;                     alpha'' := 0;
    theta  := atan(1.6*(-1)^n/0.1);  
    theta' := 0;                     theta'' := 0;
    x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
    y  := 0.1;          y' := 0;     y''     := 0;
    z  := 0.2;          z' := 0;     z''     := 0;
  end
  
  if mode <> "Wait" && mode <> "Prepare" && mode <> "Startball" && mode <> "Reset"
     mode := "Panic!";
  end;
  
  t'  = 1;   // Rate for local timer
  // pH is the hightest from my start ball(easy to calculate from y and zp)   
  pH :=  [1.5 * (-1)^n, yS, let t = abs(zp/(-9.8 +  k_a*(zp)^2));
                              a = -9.8 +  k_a*(zp)^2 in 
                    zp*t + 0.5 * (a)*t^2 end];
  switch mode
    case "Wait" // Waiting for your serve, moving the bat to start point
      v'  = ([1.6*(-1)^n,0,0.4] - p_bat) * 7 + 2 * ([0,0,0]- v);
      t   := 0;
      t1_predicted  := 0;
      t2_predicted  := 0; 
      p2_predicted  := [0,0,0];
      doneOnce      := false;
      angle_bat'     = 2*([0,0,0] - angle_bat);
      if myServe == true && starting == false
        mode := "Prepare";
      end;
      // Calculate how to get to goal point(slightly behind and below pH)
      if myServe == true && starting == true 
        t  := 0;  
        d_ballBat := norm(p_bat - pH);
        u  := (pH + [0.07*(-1)^n,0,-0.13] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.13] - p_bat);
        ta := let d_ballBat = norm(p_bat - pH) in sqrt(2 * (d_ballBat / 2) / maxA) end;
        mode := "Startball";
      end;
    case "Startball" // Start the ball as I wanted
        _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
                ["Sphere",pH,0.02,[0,100,200],[0,0,0]]];
        
        // Path planning, first half distance fully accelerate the other 
        // half fully decelerate
        if starting == false
           mode := "Prepare";
        end;
         if(t < ta)
          v' = maxA* u;
          angle_bat = [0.9471*(-1)^(n+1),0,0.7];     
        else if (t>=ta && t<2*ta)
          v' = -maxA * u;          
        else if (norm(p_ball - p_bat)>0.25)
          v' =10*([0,0,0]-v);
        // Prepare to hit the ball
        else if (norm(p_ball - p_bat)<0.25)
          v' = [-7 * (p_ball(0)),0,7];
          ta := 0;      
        end;
        end;
        end;
      end;
    case "Prepare"    // Prepare to hit the ball 
      //Do predict, and move pat towards the second predict point
      // Bouncing condition
      if (p_ball(2)) < 0 && bounced == false
        bounced := true;
      end;
      if bounced == true
        p1_predicted  = p_ball;
        v1_predicted  = v_ball;
        t1_predicted  = 0;
      else
        // Calculating first prediction point
        // Linearized air resistance
        a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball
        // 1/a in z direction
        t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2))      // -v0
                       - sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));
        p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);
        v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;
        // Check if ball is going out of bounds
        // We can predict this before it actually happens
        // This actually can decrease power consuption in some cases.
        if t > 0.2*abs(t1_predicted)
          if (p1_predicted(0))*(-1)^n > 1.55 || (p1_predicted(0))*(-1)^n < 0   
             || abs((p1_predicted(1))) > 0.78
            mode    := "Wait";
            myServe := false;
          end;
        end;
      end;

      // Predict the goal point to prepare hit the ball(only do once per turn)
      if (t1_predicted < 0.15 && t1_predicted <> 0) && 
         ((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&
         doneOnce == false
      // Calculating second prediction point
      // Linearized air resistance
      a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;
      if abs(p1_predicted(0))>1
           t2_predicted = -0.6*(v1_predicted(2)) / (a2_predicted(2));
         else
           t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));
         end;
      p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted * (t2_predicted^2);
      v2_predicted = p1_predicted + a2_predicted * t2_predicted;
      doneOnce    := true;
      // First move back a bit
      // Save 0.05 sec for hit the ball with calculated velocity and angle
      t2_predicted := t2_predicted - 0.05;
      t  := 0;
      ta := t2_predicted/2;
      u  := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      end;
      _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
              ["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]];
      
    if doneOnce == false
      v'  = ([1.6*(-1)^n,0,0.4]-p_bat) * 7 + 2 * ([0,0,0]- v);
    end;
    // Path planning, first move to p2, then wait to hit the ball
    if doneOnce == true
      ta := sqrt(2* (d_ballBat/2)/maxA);
      angle_bat = a_desired;
    /*  if(t < ta)
        v' = maxA* u;
      else if (t>=ta && t<2*ta)
        v' = -maxA * u;
      else */
      if (norm(p_ball - p_bat)>0.2)
        v' = 85 * (p2_predicted + [0.2*(-1)^n,0,0] - p_bat) + 20 * ([0,0,0]- v);
      // Prepare to hit the ball
      else if (norm(p_ball - p_bat)<0.2)
        if abs(p2_predicted(0))>1.3
         v' = -100*(v-[-0.5*abs(p2_predicted(0))*(p_ball(0)),(-0.3)^(n+1),2-v2_predicted(2)*pi/20]);
        else
         v' = -100*(v-[-2.0*(p_ball(0)),(-0.3)^(n+1),2-v2_predicted(2)*pi/20]);
        end;
        ta = 0;
      end;
      end;
    end;
    case "Reset"  // Reset the intermediate variables to its initial value
      p_bat := [1.6*(-1)^n,0,0.2];
      r      := norm([1.6,0.1,0.2]);   
      r'     := 0;                     r''     := 0;
      alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
      alpha' := 0;                     alpha'' := 0;
      theta  := atan(1.6*(-1)^n/0.1);  
      theta' := 0;                     theta'' := 0;
      
      x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
      y  := 0.1;          y' := 0;     y''     := 0;
      z  := 0.2;          z' := 0;     z''     := 0;
      v := [0,0,0];       v' := [0,0,0];
      mode := "Wait";
    case "Panic!"
  end;
  x'' = (v'(0));
  y'' = (v'(1));
  z'' = (v'(2));

  r''      = (2*x'^2 + 2*y'^2 + 2*z'^2 + 2*x*x'' + 2*y*y'' + 2*z*z'')/(2*(x^2 + y^2 + z^2)^(1/2)) 
              - (2*x*x' + 2*y*y' + 2*z*z')^2/(4*(x^2 + y^2 + z^2)^(3/2));
  alpha '' = -1 * (z''/r - (2*r'*z')/r^2 + (2*z*r'^2)/r^3 - (z*r'')/r^2)/(1 - z^2/r^2)^(1/2) 
             - ((z'/r - (z*r')/r^2)*((2*z*z')/r^2 - (2*z^2*r')/r^3))/(2*(1 - z^2/r^2)^(3/2));
  theta '' = (x''*y-x*y'')/(y^2+x^2)-(x'*y-x*y')*(2*y*y'+2*x*x')/((y^2+x^2)^2); 
  
 end
 
class Atom (n,maxA)
private
name := "Atom";
mode := "Wait"; // Initial mode is to Wait
bounced := false; // Has the ball bounced?
myServe := false; // Your turn to serve? (set by Parent)
starting := false; // Your turn to start the ball? (set by Parent)
v_ball := [0,0,0]; // Ball velocity (set by Parent)
p_ball := [0,0,0]; // Ball position (set by Parent)
p_bat := [1.6*(-1)^n,0.25,0.3]; // Bat position (set by Parent)
v := [0,0,0]; // Bat velocity
v' := [0,0,0]; // Bat accerleration
// The y position and velocity in z axis player can set to start the ball
yS := 0.5*(-1)^n;
zp := 4;
pH := [0,0,0]; // Heightest point of my start ball
angle_bat  := [0,sin(3*pi/6)*(-1)^n,-cos(3*pi/6)*(-1)^n]; // Normal vector of the bat's plane
angle_bat' := [0,0,0];
a_desired := [0.9471*(-1)^(n+1),0,0.4];
v_desired := [1.6*(1)^n,0,1.2];
// local timer
t := 0;
t' := 1;
// These coefficients are needed for prediction of ball movement
// Coefficient of restitution
k_z := [1.0, 1.0, -0.99];
// Coeffiecent of air resistance
k_a := -1/6;
// Ball acceleration (predicted)
a1_predicted := [0.0, 0.0, -9.8];
a2_predicted := [0.0, 0.0, -9.8];
// First prediction poit: time, position, speed
// When ball hits the table
t1_predicted := 0;
p1_predicted := [0, 0, 0];
v1_predicted := [0, 0, 0];
// Second prediction point: time, position, speed
// The maximum point of the second parabola
t2_predicted := 0;
p2_predicted := [0, 0, 0];
v2_predicted := [0, 0, 0];
doneOnce := false;
// Time for accelerating
ta := 0;
// Time for decelerating
td := 0;
// Unit vector of direction
u := [1,0,0];
// Distance between goal point and batp
d_ballBat := 0;
// Prediction pointers (for debugging)
_3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],
["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];
// Spherical coordinate system
r := norm([1.6,0.1,0.2]);
r' := 0; r'' := 0;
alpha := acos(0.2/norm([-1.6,0.1,0.2]));
alpha' := 0; alpha'' := 0;
theta := atan(1.6*(-1)^n/0.1);
theta' := 0; theta'' := 0;
x := 1.6*(-1)^n; x' := 0; x'' := 0;
y := 0.1; y' := 0; y'' := 0;
z := 0.2; z' := 0; z'' := 0;
end
if mode <> "Wait" && mode <> "Prepare" && mode <> "Startball" && mode <> "Reset"
mode := "Panic!";
end;
t' = 1; // Rate for local timer
// pH is the hightest from my start ball(easy to calculate from y and zp)
pH := [1.5 * (-1)^n, yS, let t = abs(zp/(-9.8 + k_a*(zp)^2));
a = -9.8 + k_a*(zp)^2 in
zp*t + 0.5 * (a)*t^2 end];
switch mode
case "Wait" // Waiting for your serve, moving the bat to start point
v' = ([1.6*(-1)^n,0,0.4] - p_bat) * 7 + 2 * ([0,0,0]- v);
t := 0;
t1_predicted := 0;
t2_predicted := 0;
p2_predicted := [0,0,0];
doneOnce := false;
angle_bat' = 2*([0,0,0] - angle_bat);
if myServe == true && starting == false
mode := "Prepare";
end;
// Calculate how to get to goal point(slightly behind and below pH)
if myServe == true && starting == true
t := 0;
d_ballBat := norm(p_bat - pH);
u := (pH + [0.07*(-1)^n,0,-0.13] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.13] - p_bat);
ta := let d_ballBat = norm(p_bat - pH) in sqrt(2 * (d_ballBat / 2) / maxA) end;
mode := "Startball";
end;
case "Startball" // Start the ball as I wanted
_3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
["Sphere",pH,0.02,[0,100,200],[0,0,0]]];
// Path planning, first half distance fully accelerate the other
// half fully decelerate
if(t < ta)
v' = maxA* u;
angle_bat = [0.9471*(-1)^(n+1),0,0.7];
else if (t>=ta && t<2*ta)
v' = -maxA * u;
else if (norm(p_ball - p_bat)>0.25)
v' =10*([0,0,0]-v);
// Prepare to hit the ball
else if (norm(p_ball - p_bat)<0.25)
v' = [-7 * (p_ball(0)),0,7];
ta := 0;
end;
end;
end;
end;
case "Prepare" // Prepare to hit the ball
//Do predict, and move pat towards the second predict point
// Bouncing condition
if (p_ball(2)) < 0 && bounced == false
bounced := true;
end;
if bounced == true
p1_predicted = p_ball;
v1_predicted = v_ball;
t1_predicted = 0;
else
// Calculating first prediction point
// Linearized air resistance
a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball
// 1/a in z direction
t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2)) // -v0
- sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));
p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);
v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;
// Check if ball is going out of bounds
// We can predict this before it actually happens
// This actually can decrease power consuption in some cases.
if t > 0.2*abs(t1_predicted)
if (p1_predicted(0))*(-1)^n > 1.55 || (p1_predicted(0))*(-1)^n < 0
|| abs((p1_predicted(1))) > 0.78
mode := "Wait";
myServe := false;
end;
end;
end;
// Predict the goal point to prepare hit the ball(only do once per turn)
if (t1_predicted < 0.15 && t1_predicted <> 0) &&
((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&
doneOnce == false
// Calculating second prediction point
// Linearized air resistance
a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;
t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));
p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted *
(t2_predicted^2);
v2_predicted = p1_predicted + a2_predicted * t2_predicted;
doneOnce := true;
// First move back a bit
// Save 0.05 sec for hit the ball with calculated velocity and angle
t2_predicted := t2_predicted - 0.05;
t := 0;
ta := t2_predicted/2;
u := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
end;
_3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]];
if doneOnce == false
v' = ([1.6*(-1)^n,0,0.4]-p_bat) * 7 + 2 * ([0,0,0]- v);
end;
// Path planning, first move to p2, then wait to hit the ball
if doneOnce == true
ta := sqrt(2* (d_ballBat/2)/maxA);
angle_bat = a_desired;
if(t < ta)
v' = maxA* u;
else if (t>=ta && t<2*ta)
v' = -maxA * u;
else if (norm(p_ball - p_bat)>0.2)
v' =5*([0,0,0]-v);
// Prepare to hit the ball
else if (norm(p_ball - p_bat)<0.2)
v' = [-30*(p_ball(0)),0,20];
ta = 0;
end;
end;
end;
end;
end;
case "Reset" // Reset the intermediate variables to its initial value
p_bat := [1.6*(-1)^n,0,0.2];
r := norm([1.6,0.1,0.2]);
r' := 0; r'' := 0;
alpha := acos(0.2/norm([-1.6,0.1,0.2]));
alpha' := 0; alpha'' := 0;
theta := atan(1.6*(-1)^n/0.1);
theta' := 0; theta'' := 0;
x := 1.6*(-1)^n; x' := 0; x'' := 0;
y := 0.1; y' := 0; y'' := 0;
z := 0.2; z' := 0; z'' := 0;
v := [0,0,0]; v' := [0,0,0];
mode := "Wait";
case "Panic!"
end;
x'' = (v'(0));
y'' = (v'(1));
z'' = (v'(2));


r'' =((x')^2+(y')^2+(z')^2+(x*x'')+(y*y'')+(z*z'')-(r')^2)/r;

alpha'' =(((-1/(r^2-z^2)^(1/2))*(((r*((r*z'')-(z*r'')))-((r'*((r*z')-(z*r')))))/(r^2)))+((((r*z')-(z*r'))/(r))*(((r*r')-(z*z'))/((r^2-z^2)^(3/2)))));

theta'' =((((y*x'')-(x*y''))/(x^2+y^2))+((((2*x*x')+(2*y*y'))*((x*y')-(y*x')))/(x^2+y^2)^2));

end



class Anonymous(n,maxA)
 private
   name      := "Anonymous";
   mode      := "Wait";   // Initial mode is to Wait
   bounced   := false;    // Has the ball bounced?
   myServe   := false;    // Your turn to serve?  (set by Parent)
   starting  := false;    // Your turn to start the ball? (set by Parent)
   v_ball    := [0,0,0];      // Ball velocity (set by Parent)
   p_ball    := [0,0,0];      // Ball position (set by Parent)
   p_bat     := [1.6*(-1)^n,0,0.2];  // Bat  position (set by Parent)
   v         := [0,0,0];      // Bat velocity
   v'        := [0,0,0];      // Bat accerleration
   
   // The y position and velocity in z axis player can set to start the ball
   yS        := 0.5*(-1)^n; 
   zp        := 4;
   pH        := [0,0,0];  // Heightest point of my start ball
   
   angle_bat  := [0,0,0.001];  // Normal vector of the bat's plane
   angle_bat' := [0,0,0];
   a_desired  := [0.9471*(-1)^(n+1),0,0.4];
   v_desired  := [1.6*(1)^n,0,1.2];
      
   // local timer
   t    := 0;
   t'   := 1;
   // These coefficients are needed for prediction of ball movement
   // Coefficient of restitution
   k_z := [1.0, 1.0, -0.99];
   // Coeffiecent of air resistance
   k_a := -1/6;
   // Ball acceleration (predicted)
   a1_predicted  := [0.0, 0.0, -9.8];
   a2_predicted  := [0.0, 0.0, -9.8];
   // First prediction poit: time, position, speed
   // When ball hits the table
   t1_predicted  := 0;
   p1_predicted  := [0, 0, 0];
   v1_predicted  := [0, 0, 0];
   // Second prediction point: time, position, speed
   // The maximum point of the second parabola
   t2_predicted  := 0;
   p2_predicted  := [0, 0, 0];
   v2_predicted  := [0, 0, 0];


   doneOnce   := false;
   // Time for accelerating
   ta         := 0;
   // Time for decelerating
   td         := 0;
   // Unit vector of direction
   u          := [1,0,0];
   // Distance between goal point and batp
   d_ballBat  := 0;
   // Prediction pointers (for debugging)
   _3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],
          ["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];


   // Spherical coordinate system
   r      := norm([1.6,0.1,0.2]);   
   r'     := 0;                     r''     := 0;
   alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
   alpha' := 0;                     alpha'' := 0;
   theta  := atan(1.6*(-1)^n/0.1);  
   theta' := 0;                     theta'' := 0;
   x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
   y  := 0.1;          y' := 0;     y''     := 0;
   z  := 0.2;          z' := 0;     z''     := 0;
 end
 
 if mode <> "Wait" && mode <> "Prepare" && mode <> "Startball" && mode <> "Reset"
    mode := "Panic!";
 end;
 
 t'  = 1;   // Rate for local timer
 // pH is the hightest from my start ball(easy to calculate from y and zp)   
 pH :=  [1.5 * (-1)^n, yS, let t = abs(zp/(-9.8 +  k_a*(zp)^2));
                             a = -9.8 +  k_a*(zp)^2 in 
                   zp*t + 0.5 * (a)*t^2 end];
 switch mode
   case "Wait" // Waiting for your serve, moving the bat to start point
     v'  = ([1.6*(-1)^n,0,0.4] - p_bat) * 7 + 2 * ([0,0,0]- v);
     t   := 0;
     t1_predicted  := 0;
     t2_predicted  := 0; 
     p2_predicted  := [0,0,0];
     doneOnce      := false;
     angle_bat'     = 2*([0,0,0] - angle_bat);
     if myServe == true && starting == false
       mode := "Prepare";
     end;
     // Calculate how to get to goal point(slightly behind and below pH)
     if myServe == true && starting == true 
       t  := 0;  
       d_ballBat := norm(p_bat - pH);
       u  := (pH + [0.07*(-1)^n,0,-0.13] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.13] - p_bat);
       ta := let d_ballBat = norm(p_bat - pH) in sqrt(2 * (d_ballBat / 2) / maxA) end;
       mode := "Startball";
     end;
   case "Startball" // Start the ball as I wanted
       _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
               ["Sphere",pH,0.02,[0,100,200],[0,0,0]]];
       
       // Path planning, first half distance fully accelerate the other 
       // half fully decelerate
        if(t < ta)
         v' = maxA* u;
         angle_bat = [0.9471*(-1)^(n+1),0,0.7];     
       else if (t>=ta && t<2*ta)
         v' = -maxA * u;          
       else if (norm(p_ball - p_bat)>0.25)
         v' =30*([0,0,0]-v);
       // Prepare to hit the ball
       else if (norm(p_ball - p_bat)<0.25)
         v' = [-50 * (p_ball(0)),0,7];
         ta := 0;      
       end;
       end;
       end;
     end;
   case "Prepare"    // Prepare to hit the ball 
     //Do predict, and move pat towards the second predict point
     // Bouncing condition
     if (p_ball(2)) < 0 && bounced == false
       bounced := true;
     end;
     if bounced == true
       p1_predicted  = p_ball;
       v1_predicted  = v_ball;
       t1_predicted  = 0;
     else
       // Calculating first prediction point
       // Linearized air resistance
       a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball
       // 1/a in z direction
       t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2))      // -v0
                      - sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));
       p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);
       v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;
       // Check if ball is going out of bounds
       // We can predict this before it actually happens
       // This actually can decrease power consuption in some cases.
       if t > 0.2*abs(t1_predicted)
         if (p1_predicted(0))*(-1)^n > 1.55 || (p1_predicted(0))*(-1)^n < 0   
            || abs((p1_predicted(1))) > 0.78
           mode    := "Wait";
           myServe := false;
         end;
       end;
     end;


     // Predict the goal point to prepare hit the ball(only do once per turn)
     if (t1_predicted < 0.15 && t1_predicted <> 0) && 
        ((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&
        doneOnce == false
     // Calculating second prediction point
     // Linearized air resistance
     a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;
     t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));
     p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted * (t2_predicted^2);
     v2_predicted = p1_predicted + a2_predicted * t2_predicted;
     doneOnce    := true;
     // First move back a bit
     // Save 0.05 sec for hit the ball with calculated velocity and angle
     t2_predicted := t2_predicted - 0.05;
     t  := 0;
     ta := t2_predicted/2;
     u  := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
     d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
     end;
     _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
             ["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]];
     
   if doneOnce == false
     v'  = ([1.6*(-1)^n,0,0.4]-p_bat) * 7 + 2 * ([0,0,0]- v);
   end;
   // Path planning, first move to p2, then wait to hit the ball
   if doneOnce == true
     ta := sqrt(2* (d_ballBat/2)/maxA);
     angle_bat = a_desired;
     if(t < ta)
       v' = maxA* u;
     else if (t>=ta && t<2*ta)
       v' = -maxA * u;
     else if (norm(p_ball - p_bat)>0.2)
       v' =5*([0,0,0]-v);
     // Prepare to hit the ball
     else if (norm(p_ball - p_bat)<0.2)
       v' = [-30*(p_ball(0)),0,20];
       ta = 0;
     end;
     end;
     end;
     end;
   end;
   case "Reset"  // Reset the intermediate variables to its initial value
     p_bat := [1.6*(-1)^n,0,0.2];
     r      := norm([1.6,0.1,0.2]);   
     r'     := 0;                     r''     := 0;
     alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
     alpha' := 0;                     alpha'' := 0;
     theta  := atan(1.6*(-1)^n/0.1);  
     theta' := 0;                     theta'' := 0;
     x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
     y  := 0.1;          y' := 0;     y''     := 0;
     z  := 0.2;          z' := 0;     z''     := 0;
     v := [0,0,0];       v' := [0,0,0];
     mode := "Wait";
   case "Panic!"
 end;
 x'' = (v'(0));
 y'' = (v'(1));
 z'' = (v'(2));
 
r''      = ((x*x''+(x')^2+y*y''+(y')^2+z*z''+(z')^2-(r')^2)/r); // Derive correct equation
theta'' = (((r^2-z^2)^(1/2))*(z*r''-z''*r)-alpha'*((2*r*(r*r'-z*z'))+r'*(r^2-z^2)))/(r*(r^2-z^2)); // Derive correct equation
alpha'' = (y*x''-x*y''-2*(x*x'+y*y')*theta')/(x^2+y^2);// Derive correct equation


end


class Panda(n,maxA)
  private
    name      := "Panda";
    mode      := "Wait";   // Initial mode is to Wait
    bounced   := false;    // Has the ball bounced?
    myServe   := false;    // Your turn to serve?  (set by Parent)
    starting  := false;    // Your turn to start the ball? (set by Parent)
    v_ball    := [0,0,0];      // Ball velocity (set by Parent)
    p_ball    := [0,0,0];      // Ball position (set by Parent)
    p_bat     := [1.6*(-1)^n,0,0.2];  // Bat  position (set by Parent)
    v         := [0,0,0];      // Bat velocity
    v'        := [0,0,0];      // Bat accerleration
    
    // The y position and velocity in z axis player can set to start the ball
    yS        := 0.5*(-1)^n;
    zp        := 4;
    pH        := [0,0,0];  // Heightest point of my start ball
    
    angle_bat  := [0,0,0.001];  // Normal vector of the bat's plane
    angle_bat' := [0,0,0];
     a_desired  := [1.0071*(-1)^(n+1),-0.1*(-1)^(n+1),0.42];
    a_desired2  := [1.0071*(-1)^(n+1),0.15,0.5];
    a_desired3  := [1.0071*(-1)^(n+1),-0.15,0.5];
    a_desired4  := [1.0471*(-1)^(n+1),0.25,0.45];
    a_desired5  := [1.0471*(-1)^(n+1),-0.25,0.45];
    a_desired6  := [0.9471*(-1)^(n+1),0.15,0.4];
    a_desired7  := [0.9471*(-1)^(n+1),-0.15,0.4];

    v_desired  := [1.6*(1)^n,0,1.2];
       
    // local timer
    t    := 0;
    t'   := 1;
 
    // These coefficients are needed for prediction of ball movement
    // Coefficient of restitution
    k_z := [1.0, 1.0, -0.99];
    // Coeffiecent of air resistance
    k_a := -1/6;
    // Ball acceleration (predicted)
    a1_predicted  := [0.0, 0.0, -9.8];
    a2_predicted  := [0.0, 0.0, -9.8];
    // First prediction poit: time, position, speed
    // When ball hits the table
    t1_predicted  := 0;
    p1_predicted  := [0, 0, 0];
    v1_predicted  := [0, 0, 0];
 
    // Second prediction point: time, position, speed
    // The maximum point of the second parabola
    t2_predicted  := 0;
    p2_predicted  := [0, 0, 0];
    v2_predicted  := [0, 0, 0];

    doneOnce   := false;
    // Time for accelerating
    ta         := 0;
    // Time for decelerating
    td         := 0;
    // Unit vector of direction
    u          := [1,0,0];
    // Distance between goal point and batp
    d_ballBat  := 0;
    // Prediction pointers (for debugging)
    _3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],
           ["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];

    // Spherical coordinate system
    r      := norm([1.6,0.1,0.2]);   
    r'     := 0;                     r''     := 0;
    alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
    alpha' := 0;                     alpha'' := 0;
    theta  := atan(1.6*(-1)^n/0.1);  
    theta' := 0;                     theta'' := 0;
    x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
    y  := 0.1;          y' := 0;     y''     := 0;
    z  := 0.2;          z' := 0;     z''     := 0;
  end
  
  if mode <> "Wait" && mode <> "Prepare" && mode <> "Startball" && mode <> "Reset"
     mode := "Panic!";
  end;
  
  t'  = 1;   // Rate for local timer
  // pH is the hightest from my start ball(easy to calculate from y and zp)   
  pH :=  [1.5 * (-1)^n, yS, let t = abs(zp/(-9.8 +  k_a*(zp)^2));
                              a = -9.8 +  k_a*(zp)^2 in 
                    zp*t + 0.5 * (a)*t^2 end];
  switch mode
    case "Wait" // Waiting for your serve, moving the bat to start point
      v'  = ([1.6*(-1)^n,0,0.4] - p_bat) * 7 + 2 * ([0,0,0]- v);
      t   := 0;
      t1_predicted  := 0;
      t2_predicted  := 0; 
      p2_predicted  := [0,0,0];
      doneOnce      := false;
      angle_bat'     = 2*([0,0,0] - angle_bat);
      if myServe == true && starting == false
        mode := "Prepare";
      end;
      // Calculate how to get to goal point(slightly behind and below pH)
      if myServe == true && starting == true 
        t  := 0;  
        d_ballBat := norm(p_bat - pH);
        u  := (pH + [0.07*(-1)^n,0,-0.12] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.12] - p_bat);
        ta := let d_ballBat = norm(p_bat - pH) in sqrt(2 * (d_ballBat / 2) / maxA) end;
        mode := "Startball";
      end;
    case "Startball" // Start the ball as I wanted
        _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
                ["Sphere",pH,0.02,[0,100,200],[0,0,0]]];
        
        // Path planning, first half distance fully accelerate the other 
        // half fully decelerate
         if(t < ta)
          v' = maxA* u;
          angle_bat' = (a_desired - angle_bat)/ta;   
        else if (t>=ta && t<2*ta)
          v' = -maxA * u;          
        else if (norm(p_ball - p_bat)>0.22)
          v' =5*([0,0,0]-v);
        // Prepare to hit the ball
        else if (norm(p_ball - p_bat)<0.22)
          v' = [-5 * (p_ball(0)),0,5];
          ta := 0;      
        end;
        end;
        end;
      end;
    case "Prepare"    // Prepare to hit the ball 
      //Do predict, and move pat towards the second predict point
      // Bouncing condition
      if (p_ball(2)) < 0 && bounced == false
        bounced := true;
      end;
      if bounced == true
        p1_predicted  = p_ball;
        v1_predicted  = v_ball;
        t1_predicted  = 0;
      else
        // Calculating first prediction point
        // Linearized air resistance
        a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball
        // 1/a in z direction
        t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2))      // -v0
                       - sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));
        p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);
        v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;
        // Check if ball is going out of bounds
        // We can predict this before it actually happens
        // This actually can decrease power consuption in some cases.
        if t > 0.2*abs(t1_predicted)
          if (p1_predicted(0))*(-1)^n > 1.55 || (p1_predicted(0))*(-1)^n < 0   
             || abs((p1_predicted(1))) > 0.78
            mode    := "Wait";
            myServe := false;
          end;
        end;
      end;

      // Predict the goal point to prepare hit the ball(only do once per turn)
      if (t1_predicted < 0.15 && t1_predicted <> 0) && 
         ((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&
         doneOnce == false
      // Calculating second prediction point
      // Linearized air resistance
      a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;
      t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));
      p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted * (t2_predicted^2);
      v2_predicted = p1_predicted + a2_predicted * t2_predicted;
      doneOnce    := true;
      // First move back a bit
      // Save 0.05 sec for hit the ball with calculated velocity and angle
      t2_predicted := t2_predicted - 0.05;
      t  := 0;
      ta := t2_predicted/2;
      u  := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0]- p_bat);
      end;
      _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
              ["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]];
      
    if doneOnce == false
      v'  = ([1.6*(-1)^n,0,0.4]-p_bat) * 8+ 2* ([0,0,0]- v);
    end;
    // Path planning, first move to p2, then wait to hit the ball
    if doneOnce == true
      ta := sqrt(2* (d_ballBat/2)/maxA);
      if p2_predicted(1)<0&&abs(p2_predicted(0))<1.4
 
      angle_bat' = (a_desired2 - angle_bat)/ta;
     else if p2_predicted(1)<-0.3&&abs(p2_predicted(0))>1.4
     angle_bat' = (a_desired4 - angle_bat)/ta;
     else if p2_predicted(1)<0&&p2_predicted(1)>-0.3&&abs(p2_predicted(0))>1.4
     angle_bat' = (a_desired6 - angle_bat)/ta;
     else if p2_predicted(1)>0&&abs(p2_predicted(0))<1.4
      angle_bat' = (a_desired3 - angle_bat)/ta;
     else if p2_predicted(1)>0.3&&abs(p2_predicted(0))>1.4
      angle_bat' = (a_desired5 - angle_bat)/ta;
      else if p2_predicted(1)>0&&p2_predicted(1)<0.3&&abs(p2_predicted(0))>1.4
      angle_bat' = (a_desired7 - angle_bat)/ta;
    end;
    end;
    end;
    end;
    end;
    end;
      if(t < ta)
        v' = maxA* u;
      else if (t>=ta && t<2*ta)
        v' = -maxA * u;
      else if (norm(p_ball - p_bat)>0.2)
        v' =5*([0,0,0]-v);
      // Prepare to hit the ball
else if (norm(p_ball - p_bat)<0.2)&&(abs(p2_predicted(1))<=1.4)
        v' = [-25*(p_ball(0)),0,15];
        ta = 0;  
      else if (norm(p_ball - p_bat)<0.2)&&(abs(p2_predicted(1))>1.4)
        v' = [-32*(p_ball(0)),0,20];
        ta = 0;
      end;
  end;
      end;
      end;
      end;
    end;
    case "Reset"  // Reset the intermediate variables to its initial value
      p_bat := [1.6*(-1)^n,0,0.2];
      r      := norm([1.6,0.1,0.2]);   
      r'     := 0;                     r''     := 0;
      alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
      alpha' := 0;                     alpha'' := 0;
      theta  := atan(1.6*(-1)^n/0.1);  
      theta' := 0;                     theta'' := 0;
      x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
      y  := 0.1;          y' := 0;     y''     := 0;
      z  := 0.2;          z' := 0;     z''     := 0;
      v := [0,0,0];       v' := [0,0,0];
      mode := "Wait";
    case "Panic!"
  end;
  x'' = (v'(0));
  y'' = (v'(1));
  z'' = (v'(2));
  
 r''  =(2*x'^2 + 2*y'^2 + 2*z'^2 + 2*x*x'' + 2*y*y'' + 2*z*z'')/(2*(x^2 + y^2 + z^2)^(1/2))- (2*x*x' + 2*y*y' + 2*z*z')^2/(4*(x^2 + y^2 + z^2)^(3/2));
 // Derive correct equation
alpha '' = -1 * (z''/r - (2*r'*z')/r^2 + (2*z*r'^2)/r^3 - (z*r'')/r^2)/(1 - z^2/r^2)^(1/2) - ((z'/r - (z*r')/r^2)*((2*z*z')/r^2 - (2*z^2*r')/r^3))/(2*(1 - z^2/r^2)^(3/2));
theta '' = (x''*y-x*y'')/(y^2+x^2)-(x'*y-x*y')*(2*y*y'+2*x*x')/((y^2+x^2)^2); 


end
class Player(n,maxA)
  private
    name      := "Player";
    mode      := "Wait";   // Initial mode is to Wait
    bounced   := false;    // Has the ball bounced?
    myServe   := false;    // Your turn to serve?  (set by Parent)
    starting  := false;    // Your turn to start the ball? (set by Parent)
    v_ball    := [0,0,0];      // Ball velocity (set by Parent)
    p_ball    := [0,0,0];      // Ball position (set by Parent)
    p_bat     := [1.6*(-1)^n,0,0.2];  // Bat  position (set by Parent)
    v         := [0,0,0];      // Bat velocity
    v'        := [0,0,0];      // Bat accerleration
    
    // The y position and velocity in z axis player can set to start the ball
    yS        := 0.5*(-1)^n;
    zp        := 4;
    pH        := [0,0,0];  // Heightest point of my start ball
    
    angle_bat  := [0,0,0.001];  // Normal vector of the bat's plane
    angle_bat' := [0,0,0];
    a_desired  := [0.9471*(-1)^(n+1),0,0.4];
    v_desired  := [1.6*(1)^n,0,1.2];
       
    // local timer
    t    := 0;
    t'   := 1;
 
    // These coefficients are needed for prediction of ball movement
    // Coefficient of restitution
    k_z := [1.0, 1.0, -0.99];
    // Coeffiecent of air resistance
    k_a := -1/6;
    // Ball acceleration (predicted)
    a1_predicted  := [0.0, 0.0, -9.8];
    a2_predicted  := [0.0, 0.0, -9.8];
    // First prediction poit: time, position, speed
    // When ball hits the table
    t1_predicted  := 0;
    p1_predicted  := [0, 0, 0];
    v1_predicted  := [0, 0, 0];
 
    // Second prediction point: time, position, speed
    // The maximum point of the second parabola
    t2_predicted  := 0;
    p2_predicted  := [0, 0, 0];
    v2_predicted  := [0, 0, 0];

    doneOnce   := false;
    // Time for accelerating
    ta         := 0;
    // Time for decelerating
    td         := 0;
    // Unit vector of direction
    u          := [1,0,0];
    // Distance between goal point and batp
    d_ballBat  := 0;
    // Prediction pointers (for debugging)
    _3D := [["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]],
           ["Sphere",[0,0,0],0.01,[200,0,0],[0,0,0]]];

    // Spherical coordinate system
    r      := norm([1.6,0.1,0.2]);   
    r'     := 0;                     r''     := 0;
    alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
    alpha' := 0;                     alpha'' := 0;
    theta  := atan(1.6*(-1)^n/0.1);  
    theta' := 0;                     theta'' := 0;
    x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
    y  := 0.1;          y' := 0;     y''     := 0;
    z  := 0.2;          z' := 0;     z''     := 0;
  end
  
  if mode <> "Wait" && mode <> "Prepare" && mode <> "Startball" && mode <> "Reset"
     mode := "Panic!";
  end;
  
  t'  = 1;   // Rate for local timer
  // pH is the hightest from my start ball(easy to calculate from y and zp)   
  pH :=  [1.5 * (-1)^n, yS, let t = abs(zp/(-9.8 +  k_a*(zp)^2));
                              a = -9.8 +  k_a*(zp)^2 in 
                    zp*t + 0.5 * (a)*t^2 end];
  switch mode
    case "Wait" // Waiting for your serve, moving the bat to start point
      v'  = ([1.6*(-1)^n,0,0.4] - p_bat) * 7 + 2 * ([0,0,0]- v);
      t   := 0;
      t1_predicted  := 0;
      t2_predicted  := 0; 
      p2_predicted  := [0,0,0];
      doneOnce      := false;
      angle_bat'     = 2*([0,0,0] - angle_bat);
      if myServe == true && starting == false
        mode := "Prepare";
      end;
      // Calculate how to get to goal point(slightly behind and below pH)
      if myServe == true && starting == true 
        t  := 0;  
        d_ballBat := norm(p_bat - pH);
        u  := (pH + [0.07*(-1)^n,0,-0.13] - p_bat)/norm(pH + [0.07*(-1)^n,0,-0.13] - p_bat);
        ta := let d_ballBat = norm(p_bat - pH) in sqrt(2 * (d_ballBat / 2) / maxA) end;
        mode := "Startball";
      end;
    case "Startball" // Start the ball as I wanted
        _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
                ["Sphere",pH,0.02,[0,100,200],[0,0,0]]];
        
        // Path planning, first half distance fully accelerate the other 
        // half fully decelerate
         if(t < ta)
          v' = maxA* u;
          angle_bat = [0.9471*(-1)^(n+1),0,0.7];     
        else if (t>=ta && t<2*ta)
          v' = -maxA * u;          
        else if (norm(p_ball - p_bat)>0.25)
          v' =10*([0,0,0]-v);
        // Prepare to hit the ball
        else if (norm(p_ball - p_bat)<0.25)
          v' = [-7 * (p_ball(0)),0,7];
          ta := 0;      
        end;
        end;
        end;
      end;
    case "Prepare"    // Prepare to hit the ball 
      //Do predict, and move pat towards the second predict point
      // Bouncing condition
      if (p_ball(2)) < 0 && bounced == false
        bounced := true;
      end;
      if bounced == true
        p1_predicted  = p_ball;
        v1_predicted  = v_ball;
        t1_predicted  = 0;
      else
        // Calculating first prediction point
        // Linearized air resistance
        a1_predicted = [0, 0, -9.8] + k_a * norm(v_ball) * v_ball;// acceleration of the ball
        // 1/a in z direction
        t1_predicted = (1/(a1_predicted(2))) * (-(v_ball(2))      // -v0
                       - sqrt((v_ball(2))^2 - 2*(a1_predicted(2))*(p_ball(2))));
        p1_predicted = p_ball + v_ball * t1_predicted + 0.5 * a1_predicted * (t1_predicted^2);
        v1_predicted = (v_ball + a1_predicted * t1_predicted) .* k_z;
        // Check if ball is going out of bounds
        // We can predict this before it actually happens
        // This actually can decrease power consuption in some cases.
        if t > 0.2*abs(t1_predicted)
          if (p1_predicted(0))*(-1)^n > 1.55 || (p1_predicted(0))*(-1)^n < 0   
             || abs((p1_predicted(1))) > 0.78
            mode    := "Wait";
            myServe := false;
          end;
        end;
      end;

      // Predict the goal point to prepare hit the ball(only do once per turn)
      if (t1_predicted < 0.15 && t1_predicted <> 0) && 
         ((n==1 && (p_ball(0))<0) || (n==2 && (p_ball(0))>0)) &&
         doneOnce == false
      // Calculating second prediction point
      // Linearized air resistance
      a2_predicted = [0, 0, -9.8] + k_a * norm(v1_predicted) * v1_predicted;
      t2_predicted = -(v1_predicted(2)) / (a2_predicted(2));
      p2_predicted = p1_predicted + v1_predicted * t2_predicted + 0.5 * a2_predicted * (t2_predicted^2);
      v2_predicted = p1_predicted + a2_predicted * t2_predicted;
      doneOnce    := true;
      // First move back a bit
      // Save 0.05 sec for hit the ball with calculated velocity and angle
      t2_predicted := t2_predicted - 0.05;
      t  := 0;
      ta := t2_predicted/2;
      u  := (p2_predicted + [0.2*(-1)^n,0,0]-p_bat)/norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      d_ballBat = norm(p2_predicted + [0.2*(-1)^n,0,0] - p_bat);
      end;
      _3D := [["Sphere",p1_predicted,0.02,[200,0,0],[0,0,0]],
              ["Sphere",p2_predicted,0.02,[0,100,200],[0,0,0]]];
      
    if doneOnce == false
      v'  = ([1.6*(-1)^n,0,0.4]-p_bat) * 7 + 2 * ([0,0,0]- v);
    end;
    // Path planning, first move to p2, then wait to hit the ball
    if doneOnce == true
      ta := sqrt(2* (d_ballBat/2)/maxA);
      angle_bat = a_desired;
      if(t < ta)
        v' = maxA* u;
      else if (t>=ta && t<2*ta)
        v' = -maxA * u;
      else if (norm(p_ball - p_bat)>0.2)
        v' =5*([0,0,0]-v);
      // Prepare to hit the ball
      else if (norm(p_ball - p_bat)<0.2)
        v' = [-30*(p_ball(0)),0,20];
        ta = 0;
      end;
      end;
      end;
      end;
    end;
    case "Reset"  // Reset the intermediate variables to its initial value
      p_bat := [1.6*(-1)^n,0,0.2];
      r      := norm([1.6,0.1,0.2]);   
      r'     := 0;                     r''     := 0;
      alpha  := acos(0.2/norm([-1.6,0.1,0.2])); 
      alpha' := 0;                     alpha'' := 0;
      theta  := atan(1.6*(-1)^n/0.1);  
      theta' := 0;                     theta'' := 0;
      x  := 1.6*(-1)^n;   x' := 0;     x''     := 0;
      y  := 0.1;          y' := 0;     y''     := 0;
      z  := 0.2;          z' := 0;     z''     := 0;
      v := [0,0,0];       v' := [0,0,0];
      mode := "Wait";
    case "Panic!"
  end;
  x'' = (v'(0));
  y'' = (v'(1));
  z'' = (v'(2));
  
  r''      = (2*x'^2 + 2*y'^2 + 2*z'^2 + 2*x*x'' + 2*y*y'' + 2*z*z'')/(2*(x^2 + y^2 + z^2)^(1/2)) - (2*x*x' + 2*y*y' + 2*z*z')^2/(4*(x^2 + y^2 + z^2)^(3/2));
  alpha '' = -1 * (z''/r - (2*r'*z')/r^2 + (2*z*r'^2)/r^3 - (z*r'')/r^2)/(1 - z^2/r^2)^(1/2) - ((z'/r - (z*r')/r^2)*((2*z*z')/r^2 - (2*z^2*r')/r^3))/(2*(1 - z^2/r^2)^(3/2));
  theta '' = (x''/y - (2*x'*y')/y^2 + (2*x*y'^2)/y^3 - (x*y'')/y^2)/(x^2/y^2 + 1) - ((x'/y - (x*y')/y^2)*((2*x*x')/y^2 - (2*x^2*y')/y^3))/(x^2/y^2 + 1)^2; 

end

/**
* Draws a cyliner between point p and q
**/

class Cylinder (D,tablerow,tablecolum)
 private 
  p   :=[0,0,0]; 
  q   :=[0,0,0];
  _3D := [];
  radius := 0.05;
  length := 0.01; alpha:=0; theta:= pi/2;
  x      := 0;    y    :=0; z    :=0;
  flag   := 0;
  color  := [1,1,1];
  shiftD := [10,5,0];          // shift distance of the ball
 end
 _3D = [["Cylinder",(p+q)/2+D+[tablerow,tablecolum,0].*shiftD,[radius,length],color,
                      [alpha,0,-theta]]];
 x = (p(0)-q(0));
 y = (p(1)-q(1));
 z = (p(2)-q(2));

  length = norm(p-q);
  if length > 0
    alpha = asin(z/length);
  else
    alpha = 0;
  end;

  if (y>0)
   theta = asin(x/(length*cos(alpha)+0.0001))
  else
   theta = -asin(x/(length*cos(alpha)+0.0001))+pi
  end
end

/**
* A three-dimentional bouncing ball model, with air resistance.
**/

class Ball (tablerow,tablecolum)
  private
    mode   := "Fly";           // always start by some player
    k_z    := [1,1,-0.99];       // Coefficient of restitution
    k2     := 1/6;               // Coefficient of the air resistance
    p      := [0,0,0.5];         // Position of the ball
    p'     := [0,0,0];
    p''    := [0,0,0];
    shiftD := [10,5,0];          // shift distance of the ball      
    _3D    := [];
  end
 
 // If mode is not valid then make mode "Panic!"
  if mode <> "Fly" && mode <> "Bounce" && mode <> "Freeze"
     mode := "Panic!";
  end;
 // Behavior of ball in different modes
  switch mode
    case "Fly"
      if (p(2)) < 0 && (p'(2))< 0
        mode := "Bounce";
      else // Acceleration is air resistance and gravity
        p'' = -k2 * norm(p') * p' + [0,0,-9.8];
      end;
    case "Bounce"
      p'   :=  p' .* k_z; // Bounce losing k_z energy
      mode := "Fly";
    case "Freeze"       // The ball becomes red and freezes for a bit
      p'  := [0,0,0]; 
      p'' := [0,0,0];
    case "Panic!"
  end;
  if (mode == "Freeze")
    _3D = ["Sphere",p+[tablerow,tablecolum,0].*shiftD,0.03,[1,0,0],[0,0,0]];
  else
    _3D = ["Sphere",p+[tablerow,tablecolum,0].*shiftD,0.03,[1,1,1],[0,0,0]];
  end;
end

/**
* Actorator for moving the bat, which also keeps track of the energy spent.
**/

class BatActuator(n,p1,tablerow,tablecolum,maxE)
  private
    mode    := "Normal";
    p       := p1;
    p'      := [0,0,0];
    p''     := [0,0,0];
    angle   := [0,0,0];
    energy  := 0;
    energy' := 0;
    // Mass of the bat
    m := 0.1;
    F := 0; 
    // Visualize energy spent
    eb  := create Cylinder([0,0,0],tablerow,tablecolum);
    offset := 0;
    // Visualize the arm
    link1 := create Cylinder([0,0,0],tablerow,tablecolum);
    link2 := create Cylinder([0,0,0],tablerow,tablecolum);
    L1    := 0.4;  // Length of link1 is fixed
    baseP := [2.4*(-1)^n,0,0.3];
    unit := [0,0,0]; // Unit vector from baseP to P
    r      := norm([1.6,0.1,0.2]);
    r'     := 0;                     r''     := 0;
    alpha  := acos(0.2/norm([1.6,0.1,0.2])); 
    alpha' := 0;                     alpha'' := 0;
    theta  := atan(1.6*(-1)^n/0.1); 
    theta' := 0;                     theta'' := 0;
  end
  // If mode is not valid then make mode "Panic!"
  if mode <> "Normal" && mode <> "Reset"
    mode := "Panic!";
  end;
  switch mode
    case "Normal"
      F      = m * norm(p'');
      if norm(p') > 5 // ???Saturate??? speeds over 5
        p' := p'/norm(p') * 5 ;
      end;
      energy' = F*norm(p'); // Simplistic model of power consumed
      // Transformation from Spherical coordinate to Cartesian coordinate system
      if(energy < maxE) 
       p'' = let sast = sin(alpha)*sin(theta);
                 sact = sin(alpha)*cos(theta);
                 cast = cos(alpha)*sin(theta);
                 cact = cos(alpha)*cos(theta);
             in
             [sast*r'' - sast*r*theta'^2 + 
                // // // sact*r*alpha'' // Faulty term
                sact*r*theta'' // Correct term 
              + 2*cast*alpha'*r' + 2*sact*r'*theta' -     sast*r*alpha'^2 + cast*r*alpha''+2*cact*r*alpha'*theta',
              sact*r'' - sast*r*theta'' + 2*cact*alpha'*r' - 2*sast*r'*theta' - sact*r*alpha'^2 + cact*r*alpha'' - sact*r*theta'^2 - 2*cast*r*alpha'*theta',
              cos(alpha)*r'' - 2*sin(alpha)*alpha'*r' - cos(alpha)*r*alpha'^2 - sin(alpha)*r*alpha''
             ]end;
      end;
      // Visualize arm
      unit = (p - baseP)/norm(p - baseP);
      link1.q = baseP;
      link1.p = baseP + L1 * unit;
      link1.radius = 0.1;
      link2.q = link1.p;
      link2.p = p +  [(-1)^n * 0.05,0,0];
      link2.radius = 0.03;
    case "Reset"
      p       := p1;
      p'      := [0,0,0];
      p''     := [0,0,0];
      angle   := [0,0,0];
      r      := norm([1.6,0.1,0.2]);
      r'     := 0;                     r''     := 0;
      alpha  := acos(0.2/norm([1.6,0.1,0.2])); 
      alpha' := 0;                     alpha'' := 0;
      theta  := atan(1.6*(-1)^n/0.1); 
      theta' := 0;                     theta'' := 0;
      mode    := "Normal";
    case "Panic!"
  end;
  // Energy bar visualization
  offset = (energy/maxE)*1.5;
  eb.p = [(-1)^n * 1.5, -0.8, -0.05];
  eb.q = [(-1)^n * 1.5 + (-1)^(n+1) * offset, -0.8, -0.05];
  eb.radius = 0.02;
  eb.color = [0.2,1,0.2];
 
end

/**
* For visualizing the bat
**/
class Bat(n,p1,tablerow,tablecolum)
  private
    p       := p1;
    pv      := [0,0,0];
    angle   := [0,0,0];
    displayAngle := [0,0,0];
    shiftD  := [10,5,0];
    unitX   := 0;
    unitY   := 0;
    unitZ   := 0;
    mode    := "Run";
    _3D     := [];
  end
  switch mode
    case "Run"
      if n == 2
        displayAngle = [(angle(2))*(pi/2),0,
                       (angle(1))*(pi/2)]+[0,0,pi/2];
        _3D = ["Cylinder",p+[0.05,0,0]+[tablerow,tablecolum,0].*shiftD,[0.15,0.05],
                [0.1,0.1,0.1],displayAngle];
      else
        displayAngle = [(-angle(2))*(pi/2),0,
                       (angle(1))*(pi/2)]+[0,0,pi/2];
        _3D = ["Cylinder",p+[-0.05,0,0]+[tablerow,tablecolum,0].*shiftD,[0.15,0.05],
                [1,0.1,0.1],displayAngle];
      end;
    case "Rest"
      pv := [0,0,0]; // Set speed to 0 in ???Rest??? mode
      _3D = ["Box",p+[-0.05,0,0]+[tablerow,tablecolum,0].*shiftD,[0.3,0.3,0.3],
                [1,1,0.1],-1 * displayAngle];
  end
end

class Table(offset,shiftD)   // The table (a static 3D object)
  private
     _3D :=[["Box", [0,0,-0.05]+offset.*shiftD,[3,1.5,0.03],[0.1,0.1,1.0],[0,0,0]],
        // TableBases 1~4
        ["Box", [-1.4,0.6,-0.3-0.04]+offset.*shiftD, [0.05,0.05,0.6],
                [0.8,0.8,0.8],[0,0,0]],
        ["Box", [-1.4,-0.6,-0.3-0.04]+offset.*shiftD, [0.05,0.05,0.6],
                [0.8,0.8,0.8],[0,0,0]],
        ["Box", [1.4,-0.6,-0.3-0.04]+offset.*shiftD, [0.05,0.05,0.6], 
                [0.8,0.8,0.8],[0,0,0]],
        ["Box", [1.4,0.6,-0.3-0.04]+offset.*shiftD, [0.05,0.05,0.6], 
                [0.8,0.8,0.8],[0,0,0]],
        // Net
        ["Box", [0,0,0.125-0.02]+offset.*shiftD, [0.05,1.5,0.25],
                [0.2,0.8,0.2],[0,0,0]],
        // MiddleLine
        ["Box", [0,0,0]+offset.*shiftD,[3,0.02,0.02-0.02],[1,1,1],[0,0,0]]];
 end;
end

/**
* Observer who estimate ball's velocity based on its positions
**/
class BallObserver()
  private
    mode := "Sample";
    p  := [0,0,0];  // Ball position (set by Parent)
    v  := [0,0,0];  // Ball velocity (estimated here)
    pp := [0,0,0];
    ap := [0,0,0];
    t  := 0;
    t' := 1;
  end
  t'=1;
  if mode <> "Sample" && mode <> "Estimate0" && mode <> "Estimate1"
     mode := "Panic!";
  end;
  switch mode
    case "Sample"
      if t > 0
        pp  := p;
        t   := 0;
        mode:= "Estimate0"
      end;
    case "Estimate0"
      if t == 0.01   // Estimating average speed
        ap   := p;
        mode := "Estimate1";
      end;
    case "Estimate1"
      v    := (ap(0)-pp(0))/0.01*[1,0,0]+(ap(2)-pp(2))/0.01*[0,0,1]+
              (ap(1)-pp(1))/0.01*[0,1,0];
      mode := "Sample";
      t    := 0;
    case "Panic!"
  end
end


// This class monitors the whole game.
class Referee()  
  private
    mode:="Initialize";
    // Position and velocity of the ball
    p := [0,0,0];p' := [0,0,0];   
    t := 0;   t' := 1;
    player1Score := 0;
    player2Score := 0;
    serveNumber  := 2;
    lastHit      := 0;
    reason       := "Nothing";
    checked      := false;    // For the net checking
    bounced      := false;    
    restart      := 0;        // Tell the Game to restart
    acknowledged := 0;        // Check if the Game class has received
                              //  the restart signal
    bounceTime   := 0;
    status       := "Normal"
  end
  
  if mode <> "Initialize" && mode <> "Player1Lost" && mode <> "Player2Lost"
    && mode <> "SendMessage1" && status <> "Normal" && reason <> "Nothing"
    && status <> "Report" && reason <> "BallOutOfBoundary" && mode <> "SendMessage2"
    && reason <> "BallBouncedTwice" && reason <> "BallTouchNet" && reason <> "BallNotOverNet"

    mode := "Panic!";
  end;
  t'=1;
  // Whenever ball is about to hit the ground, check if anyone fouls(outside, fail to serve)
  if p(2)<0.05 && p'(2)<0 && status == "Normal"  
    // Ball fly outside the table case
    if (abs(p(1))>0.78||abs(p(0))>1.53) && status == "Normal"
      reason     := "BallOutOfBoundary";
      if bounced == false
        if lastHit == 1
          mode := "Player1Lost";
        else if lastHit == 2
          mode := "Player2Lost";
        end;
      end;
      else
        if bounced == "YesIn2"      // The ball has bounced in player2's court,
          mode := "Player2Lost";    // and out of boundary now, so player2 lose.
        end;
        if bounced == "YesIn1"
          mode := "Player1Lost";
        end;
      end;
      status := "Report";
    end;
    // Fail to serve the ball back
    if (abs(p(1))<=0.78 && abs(p(0))<=1.53) && bounced <> false 
       && status=="Normal" && abs(p(0))>0.025
      if bounced == "YesIn1" && lastHit == 1 && p(0) < 0
        mode       := "Player1Lost";
        reason     := "BallNotOverNet";
        bounced    := true;
      end;
      if bounced == "YesIn2" && lastHit == 2 && p(0) > 0
        mode       := "Player2Lost";
        reason     := "BallNotOverNet";
        bounced    := true;
      end;
    end;
    if(abs(p(1))<=0.78 && abs(p(0))<=1.53) && bounced <> false
      && t>(bounceTime+0.1) && status=="Normal"
    // The ball has bounced twice in player2's court
      if bounced == "YesIn2" && p(0) > 0 && lastHit == 1
        mode   := "Player2Lost";
        reason := "BallBouncedTwice";
        bounceTime := t;
      end;
    // The ball has bounced twice in player1's court
      if bounced == "YesIn1" && p(0) < 0 && lastHit == 2
        mode   := "Player1Lost";
        reason := "BallBouncedTwice";
        bounceTime := t;
      end;
    end;
    if p(0)<0 && p(0)>-1.53 && bounced == false && status == "Normal"
      bounced    := "YesIn1";
      bounceTime := t;
    end;
    if p(0)>=0 && p(0)<1.53 && bounced == false && status == "Normal"
      bounced    := "YesIn2";
      bounceTime := t;
    end;
  end;
  if bounced == "YesIn1" && p(0)>0 && status == "Normal"
    bounced := false
  end;
  if bounced == "YesIn2" && p(0)<=0 && status == "Normal"
    bounced := false
  end;
  // Time to check if the ball touches the net
  if abs(p(0))<0.025 && t>0.1 && checked == false && status == "Normal"
    if p(2)<0.25
      if p'(0)>0
        mode   := "Player1Lost";
      else
        mode   := "Player2Lost"
      end;
      reason  := "BallTouchNet";
      checked := true;
    end;
  end;
  switch mode
    // Put the intermediate variables to its iniital value
    case "Initialize"
      if acknowledged == 1
        mode := "Initialize";
        acknowledged  := 0;
        restart       := 0;
        status        := "Normal";
        checked       := false;
        bounced       := false;
      end;
    // Update the score and notify the Game class
    case "Player1Lost"
      player2Score := 1+player2Score;
      mode := "SendMessage1";
    case "Player2Lost"
      player1Score := 1+player1Score;
      mode := "SendMessage2";
    // Make sure Game class gets the message then go back to initial state
    case "SendMessage1"
      t := 0; // Wait until the Game class gets the restart signal
      if acknowledged == 1
        mode := "Initialize";
        acknowledged := 0;
        restart      := 0;
        status       := "Normal";
        checked      := false;
        bounced      := false;
      else 
        restart      := 1;
      end;
    case "SendMessage2"
      t := 0; // Wait until the Game class gets the restart signal
      if acknowledged  == 1
        mode := "Initialize";
        acknowledged := 0;
        restart      := 0;
        status       := "Normal";
        checked      := false;
        bounced      := false;
      else 
        restart      := 1;
      end;
    case "Panic!"
  end
end

/**
* The parent of all the other classes, who controls the information flow between 
* different children class and visualize the game progress.
**/
class Game (player1,player2,tablerow, tablecolum,gameLength)
  private
    player1 := create player1(1,30); // First Player;
    player2 := create player2(2,30); // Second Player;
    ball    := create Ball (tablerow, tablecolum);
    ballob  := create BallObserver();
    batActuator1 := create BatActuator(1,[-1.6,0,0.2],tablerow,tablecolum,30);
    batActuator2 := create BatActuator(2,[1.6,0,0.2],tablerow,tablecolum,30);
    bat1    := create Bat(1,[-1.6,0,0.2],tablerow, tablecolum);
    bat2    := create Bat(2,[1.6,0,0.2],tablerow, tablecolum);
    table   := create Table([tablerow, tablecolum, 0], [10,5,0]);
    gameMonitor  := create Referee();
    mode         := "Init";       // Player2 starts first
    player2Score := 0;
    player1Score := 0;
    gameScore1   := 0;
    gameScore2   := 0;
    serveNumber  := 2;
    first_serve  := 2;
    finish       := false;
    t  := 0;
    t' := 1;
    maxEnergy   := 30;
    shiftD      := [10,5,0];
    gameTime    := 0;            //for calculate the game length
    gameTime'   := 1;
    batRadius   := 0.2;
    changeServe := 1;         //for change the serve everytime
    _3D         := [];
    // Return numbers 
    r1 := 0; r2 := 0;
    finalScore1 := 0;
    finalScore2 := 0;

    //******* For Debug        
    zc1 := 0;
    zc2 := 0;
    zc3 := 0;
  end
  _3D = [["Text",[-1.5,1.5,0.6]+[tablerow,tablecolum,0].*shiftD,0.2,red,[1.7,0,0],player1.name],
         ["Text",[-1.5,1.5,0.3]+[tablerow,tablecolum,0].*shiftD,0.2,blue,[1.7,0,0],player1Score],
         ["Text",[-0.5,1.5,0.3]+[tablerow,tablecolum,0].*shiftD,0.2,green,[1.7,0,0],finalScore1],
         ["Text",[-1.2,1.5,0.3]+[tablerow,tablecolum,0].*shiftD,0.2,yellow,[1.7,0,0],r1],
         ["Text",[ 0.5,1.5,0.6]+[tablerow,tablecolum,0].*shiftD,0.2,red,[1.7,0,0],player2.name],
         ["Text",[ 0.5,1.5,0.3]+[tablerow,tablecolum,0].*shiftD,0.2,blue,[1.7,0,0],player2Score],
         ["Text",[ 1.5,1.5,0.3]+[tablerow,tablecolum,0].*shiftD,0.2,green,[1.7,0,0],finalScore2],
         ["Text",[ 0.8,1.5,0.3]+[tablerow,tablecolum,0].*shiftD,0.2,yellow,[1.7,0,0],r2]];
/*
  _3D = [["Text",[-3.5,6.5,-4]+[tablerow,tablecolum,0].*shiftD,1,[0.9,0,0],[1.7,0,0],player1.name],
         ["Text",[1.5,6.5,-4]+[tablerow,tablecolum,0].*shiftD,1,[0.1,0.1,0.1],[1.7,0,0],player2.name],
         ["Text",[-1.8,6.5,-5]+[tablerow,tablecolum,0].*shiftD,1,[0.6,0,0],[1.7,0,0],player1Score],
         ["Text",[3.5,6.5,-5]+[tablerow,tablecolum,0].*shiftD,1,[0.1,0.1,0.1],[1.7,0,0],player2Score],
         ["Text",[-1.8,6.5,-6]+[tablerow,tablecolum,0].*shiftD,1,[0.6,0,0],[1.7,0,0],finalScore1],
         ["Text",[3.5,6.5,-6]+[tablerow,tablecolum,0].*shiftD,1,[0.1,0.1,0.1],[1.7,0,0],finalScore2],
         ["Text",[-1.8,6.5,1.5]+[tablerow,tablecolum,0].*shiftD,1,[0.6,0,0],[1.7,0,0],r1],
         ["Text",[3.5,6.5,1.5]+[tablerow,tablecolum,0].*shiftD,1,[0.1,0.1,0.1],[1.7,0,0],r2]];
*/
  //add two modes for alternating start the game
  if mode <> "Restart1"      && mode <> "Player1Serve"  && mode <> "Player2Serve" 
  && mode <> "Impact"        && mode <> "Freeze"       && mode <> "ChangeSide"   
  && mode <> "Act"           && mode <> "Endgame"       && mode <> "Init"  
  && mode <> "Restart2"      && mode <> "StartBall1"
  && mode <> "StartBall2"
    mode := "Panic!"
  end;
  t'=1;
  gameTime' = 1;
  if gameTime > gameLength
    gameTime := 0;
    finish   := true;
  end;
  if finish == true
    mode := "Endgame"; 
  end;
  gameMonitor.p  = ball.p;
  gameMonitor.p' = ball.p';
  gameMonitor.serveNumber = serveNumber;
  player1Score   = gameMonitor.player1Score;
  player2Score   = gameMonitor.player2Score;
  ballob.p       = ball.p;
  player1.p_ball  = ballob.p;
  player2.p_ball  = ballob.p;
  player1.v_ball  = ballob.v;
  player2.v_ball  = ballob.v;
  if bat1.mode <> "Rest" && gameTime <= gameLength
    batActuator1.r''     = player1.r'';
    batActuator1.alpha'' = player1.alpha'';
    batActuator1.theta'' = player1.theta'';
    batActuator1.angle   = player1.angle_bat;
  end;
  if bat2.mode <> "Rest" && gameTime <= gameLength
    batActuator2.r''     = player2.r'';
    batActuator2.alpha'' = player2.alpha'';
    batActuator2.theta'' = player2.theta'';
    batActuator2.angle   = player2.angle_bat;
  end;
  player1.p_bat = bat1.p;
  player2.p_bat = bat2.p;
  bat1.p  = batActuator1.p;
  bat1.pv = batActuator1.p';
  bat2.p  = batActuator2.p;
  bat2.pv = batActuator2.p';
  bat1.angle = batActuator1.angle;
  bat2.angle = batActuator2.angle;
  if batActuator1.energy > maxEnergy
    bat1.mode            := "Rest";
    bat1.pv              := [0,0,0];
    batActuator1.p'       = [0,0,0];
    batActuator1.p''      = [0,0,0]; 

  end;
  if batActuator2.energy > maxEnergy
    bat2.mode            := "Rest";
    bat2.pv              := [0,0,0];
    batActuator2.p'       = [0,0,0];
    batActuator2.p''      = [0,0,0];
  end;
  switch mode
    case "Init"
      batActuator2.p := [1.6,0,0.2]; //Initialize the bat pos
      batActuator1.p := [-1.6,0,0.2];
      ball.mode      := "Fly";
      if first_serve == 1  // left serve first
        ball.p              := [-1.5,player1.yS,0]; //Initialize the ball pos
        gameMonitor.lastHit := 1;
        changeServe         := 2;
        serveNumber         := 1;
        mode                := "StartBall1";
      else                // right serve first
        ball.p              := [1.5,player2.yS,0]; //Initialize the ball pos
        gameMonitor.lastHit := 2;
        changeServe         := 1;
        serveNumber         := 2;
        mode                := "StartBall2";
      end;
    case "Restart1" // Put everything back to the starting point
      ball.p            := [-1.5,player1.yS,0];
      ball.mode         := "Fly";
      ball.p'           := [0,0,0];
      ball.p''          := [0,0,0];
      
      player2.bounced   := false;
      player2.myServe   := false;
      player2.starting  := false;
      player2.mode      := "Reset";
      
      player1.bounced   := false;
      player1.myServe   := false;
      player1.starting  := false;
      player1.p_ball    := [-1.5,player1.yS,0];
      player1.mode      := "Reset";

      batActuator1.mode := "Reset"; 
      batActuator2.mode := "Reset"; 
      
      serveNumber               := 1;
      gameMonitor.bounced       := false;
      gameMonitor.checked       := false;
      gameMonitor.acknowledged  := 1;
      gameMonitor.lastHit       := 1;
      changeServe               := 2;
      mode                      := "StartBall1";
    case "Restart2" // Put everything back to the starting point
      ball.p            := [1.5,player2.yS,0];
      ball.mode         := "Fly";
      ball.p'           := [0,0,0];

      
      player2.bounced   := false;
      player2.myServe   := false;
      player2.starting  := false;
      player2.mode      := "Reset";
      player2.p_ball    := [1.5,player2.yS,0];
      
      player1.bounced   := false;
      player1.myServe   := false;
      player1.starting  := false;
      player1.mode      := "Reset";

      batActuator1.mode := "Reset"; 
      batActuator2.mode := "Reset"; 
      
      serveNumber               := 2;
      gameMonitor.bounced       := false;
      gameMonitor.checked       := false;
      gameMonitor.acknowledged  := 1;
      gameMonitor.lastHit       := 2;
      changeServe               := 1;
      mode                      := "StartBall2";     
    case "StartBall1"
      if batActuator2.energy > maxEnergy && batActuator1.energy > maxEnergy
        mode := "Endgame";
        t    := 0;
      else if batActuator1.energy > maxEnergy && batActuator2.energy < maxEnergy
        mode := "Restart2";
        t    := 0;
      else
        ball.p'           := [0,0,player1.zp];
        player1.myServe   := true;
        player1.starting  := true;
        mode := "Player1Serve";
      end;
      end;
    case "StartBall2"
      if batActuator2.energy > maxEnergy && batActuator1.energy > maxEnergy
        mode := "Endgame";
        t    := 0;
      else if batActuator2.energy > maxEnergy && batActuator1.energy < maxEnergy
        mode := "Restart1";
        t    := 0;
      else
        ball.p'           := [0,0,player2.zp];
        player2.myServe   := true;
        player2.starting  := true;
        mode              := "Player2Serve";
      end;
      end;
    case "Player2Serve" // Player 2 is serving
      if batActuator2.energy > maxEnergy && batActuator1.energy > maxEnergy
        mode := "Endgame";
        t    := 0;
      else
        player1.myServe  = false;
        player2.myServe  = true;
        zc1 = dot((ball.p - bat2.p), bat2.angle);
        zc2 = dot((ball.p'- bat2.pv),bat2.angle);
        zc3 = norm((ball.p - bat2.p) - dot((ball.p - bat2.p), bat2.angle)*bat2.angle);
        if dot((ball.p - bat2.p), bat2.angle) < 0 &&
           dot((ball.p'- bat2.pv),bat2.angle) < 0 &&
           zc3 < batRadius &&
           gameMonitor.restart <> 1
          ball.p'            := ball.p' -dot((1.5)*(ball.p'-batActuator2.p'),batActuator2.angle)*batActuator2.angle;
          player2.myServe    := false;
          player2.starting   := false;
          r2                 := r2+1;
          player2.mode       := "Wait";
          gameMonitor.lastHit:= 2;
          mode               := "ChangeSide";
        else if gameMonitor.restart == 1 && gameTime <= gameLength
          mode := "Freeze";
          t    := 0;
        end;
        end;
        if gameMonitor.acknowledged == 1
          gameMonitor.restart := 0;
        end;
      end;
    case "Player1Serve" // Player 1 is serving     
      if batActuator2.energy > maxEnergy && batActuator1.energy > maxEnergy
        mode := "Endgame";
        t    := 0;
      else
        player2.myServe  = false;
        player1.myServe  = true;
        zc1 = dot((ball.p - bat1.p), bat1.angle);
        zc2 = dot((ball.p'- bat1.pv),bat1.angle);
        zc3 = norm((ball.p - bat1.p) - dot((ball.p - bat1.p), bat1.angle)*bat1.angle);
        if dot((ball.p - bat1.p), bat1.angle) < 0 &&
           dot((ball.p'- bat1.pv),bat1.angle) < 0 &&
           zc3 < batRadius &&
           gameMonitor.restart <> 1
          ball.p'            := ball.p' -dot((1.5)*(ball.p'-batActuator1.p'),batActuator1.angle)*batActuator1.angle;
          player1.myServe    := false;
          player1.mode       := "Wait";
          player1.starting   := false;
          r1                 := r1 + 1; 
          gameMonitor.lastHit:= 1;
          mode               := "ChangeSide";
        else if gameMonitor.restart == 1 && gameTime <= gameLength
          mode := "Freeze";
          t    := 0;
        end;
        end;
        if gameMonitor.acknowledged == 1
            gameMonitor.restart := 0;
        end;
      end;
    case "ChangeSide" // Change the serve number
      if gameMonitor.restart == 1 && gameTime <= gameLength
        mode := "Freeze";
        t    := 0;
      else
        if serveNumber == 2 && dot(ball.p,[1,0,0]) >0 && gameMonitor.restart <> 1
          serveNumber     := 1;
          mode            := "Player1Serve";
          //player1.mode  := "Wait";
          player1.bounced := false;
        end;
        if serveNumber == 1 && dot(ball.p,[1,0,0]) <= 0 && gameMonitor.restart <> 1
          serveNumber     := 2;
          mode            := "Player2Serve";
          //player2.mode  := "Wait";
          player2.bounced := false;
        end;
      end;
 // When someone fouls, showing what's going wrong for 1 second
    case "Freeze"
      if t<1
        ball.mode := "Freeze";
      else
        if gameTime <= gameLength
          if changeServe == 1
            mode      := "Restart1";
          else
            mode      := "Restart2";
          end;
        end;
        ball.p'  := [0,0,0];
        ball.p'' := [0,0,0];
      end;
    case "Endgame"
      ball.mode        := "Freeze";
      bat1.pv          := [0,0,0];
      bat2.pv          := [0,0,0];
      // Scoring function 
      //(sum(i,r_i_min * r_i_max))*s_max/min for winner/loser
      finalScore1      := (r1*r2)*player1Score;
      finalScore2      := (r1*r2)*player2Score;
    case "Panic!"
  end
end

class Main(simulator)
  private
    mode     := "Initialize";
    t        := 0;
    t'       := 1;
    j        := 0;


// Players to include:
// Most frequent winners:  [Joshua], [Pawanism], [Gatz], 
//                         [Falafel], Anonymous, [LPHP], ANG, [Dexter]
// Ocassional winners:  [ErrorTeam], [Sparta], Machine, [Avengers]
// Honorable mention:   PeeWee

    players  := // List tournament players here.
       [ // Comment A=>B means score against player with A correct and
         //              then B incorrect spherical conversion
       // Player
       // , Falafel    // + Great player -      256 => 189
       // , Pawanism   // + Good player         192 => 280
       // , Dexter     // + OK player           168 => 0
       // , LPHP       // + Great player -      189 => 378
       // , Joshua     // + Great player          ? => 288
       // , Gatz       // + Can't return -        0 => 0
       // , PeeWee     // . Great player -      256 => 288 // Causes errors
       // , Panda      //   OK -                189 => 112
       // , Atom       //   OK -                 72 => 128
       // , TheAvengers// OK, loses to player    63 => 49
       // , ErrorTeam  // - OK -                 24 => 0
       // , Endless    //   OK -                  0 => 149
       // , LPD        // Serve but no return     0 => 0
       // , Wallace    // Can't return -          0 => 42
       // , Sparta     // - OK -                  0 => 0
       // , Anonymous  // Can't return a ball     0 => 0
       Falafel, Joshua];
  end
  t' = 1;
  switch mode
    case "Initialize"
      simulator.endTime  := 20.5;
      simulator.timeStep := 0.01;
      for   i = 0:(length(players)-1)
        for j = (i+1):(length(players)-1)
            create Game(players(i), players(j), i, j-1,20);
        end;
      end;
      mode := "Persist";
    case "Persist"
  end
end


